{% load static %}
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link
      rel="apple-touch-icon"
      sizes="57x57"
      href="{% static 'apple-icon-57x57.png' %}"
    />
    <link
      rel="apple-touch-icon"
      sizes="60x60"
      href="{% static 'apple-icon-60x60.png' %}"
    />
    <link
      rel="apple-touch-icon"
      sizes="72x72"
      href="{% static 'apple-icon-72x72.png' %}"
    />
    <link
      rel="apple-touch-icon"
      sizes="76x76"
      href="{% static 'apple-icon-76x76.png' %}"
    />
    <link
      rel="apple-touch-icon"
      sizes="114x114"
      href="{% static 'apple-icon-114x114.png' %}"
    />
    <link
      rel="apple-touch-icon"
      sizes="120x120"
      href="{% static 'apple-icon-120x120.png' %}"
    />
    <link
      rel="apple-touch-icon"
      sizes="144x144"
      href="{% static 'apple-icon-144x144.png' %}"
    />
    <link
      rel="apple-touch-icon"
      sizes="152x152"
      href="{% static 'apple-icon-152x152.png' %}"
    />
    <link
      rel="apple-touch-icon"
      sizes="180x180"
      href="{% static 'apple-icon-180x180.png' %}"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="192x192"
      href="{% static 'android-icon-192x192.png' %}"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="32x32"
      href="{% static 'favicon-32x32.png' %}"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="96x96"
      href="{% static 'favicon-96x96.png' %}"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="16x16"
      href="{% static 'favicon-16x16.png' %}"
    />
    <link rel="manifest" href="{% static 'manifest.json' %}" />
    <meta name="msapplication-TileColor" content="#ffffff" />
    <meta name="msapplication-TileImage" content="/ms-icon-144x144.png" />
    <meta name="theme-color" content="#ffffff" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Puerto Rico Health Indicators Map</title>
    <!-- MapLibre GL JS -->
    <link
      href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css"
      rel="stylesheet"
    />
    <script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>

    <style>
      /* --- 1. Global & Basic Resets --- */
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Helvetica, Arial, sans-serif;
        background-color: #f4f7f6;
        color: #333;
        display: flex;
        flex-direction: column;
        min-height: 100vh;
        line-height: 1.6;
      }

      /* --- 2. Header --- */
      header {
        background-color: rgb(60, 0, 88);
        color: white;
        padding: 15px 20px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 10px;
      }
      header h1 {
        margin: 0;
        font-size: 1.5em;
        text-align: center;
        order: 1;
      }
      .header-logos-container {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 20px;
        order: 2;
      }
      .header-logo {
        height: 40px;
        max-width: 120px;
        object-fit: contain;
      }

      /* --- 3. Main Content Area (Mobile First) --- */
      .main-content {
        flex-grow: 1;
        padding: 15px;
      }

      .sidebar,
      .map-container {
        background-color: #ffffff;
        padding: 15px;
        border-radius: 8px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        width: 100%;
        margin-bottom: 20px;
      }
      .main-content > *:last-child {
        margin-bottom: 0;
      }
      .sidebar {
        overflow-y: auto;
        overflow-x: hidden;
      }

      .map-container {
        display: flex;
        flex-direction: column;
      }

      #map {
        width: 100%;
        height: 400px; /* Mobile height */
        border-radius: 8px;
        border: 1px solid #ddd;
        flex-shrink: 0;
      }
      /* MapLibre specific: ensure cursor changes work */
      .maplibregl-canvas-container.maplibregl-interactive, .maplibregl-ctrl-group button.maplibregl-ctrl-compass {
        cursor: grab;
      }
      .maplibregl-canvas-container.maplibregl-interactive.maplibregl-grabbing {
        cursor: grabbing;
      }


      .sidebar h2 {
        margin-top: 0;
        font-size: 1.3em;
        color: #004d40;
        border-bottom: 2px solid #b2dfdb;
        padding-bottom: 10px;
        margin-bottom: 15px;
      }
      .control-group {
        margin-bottom: 20px;
      }
      .control-group label {
        display: block;
        margin-bottom: 8px;
        font-weight: 600;
        color: #555;
      }
      .control-group select {
        width: 100%;
        padding: 10px;
        border-radius: 4px;
        border: 1px solid #ccc;
        background-color: #fff;
        font-size: 0.95em;
      }
      .metric-description-panel {
        padding: 10px;
        background-color: #f9f9f9;
        border: 1px solid #eee;
        border-radius: 4px;
        font-size: 0.9em;
        color: #333;
        min-height: 60px;
        margin-top: 5px;
      }
      .metric-description-panel p {
        margin: 0 0 5px 0;
      }
      .metric-description-panel strong {
        color: #004d40;
      }

      /* --- 4. Legend Styles (Redesigned) --- */
      #legend-container {
        margin-top: 15px;
        padding: 16px 0 8px 0;
        border-top: 1px solid #e0e0e0;
        width: 100%;
        background: #fafbfc;
        border-radius: 0 0 8px 8px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.03);
      }
      #legend-container > label {
        display: block;
        text-align: center;
        font-weight: 700;
        color: #333;
        margin-bottom: 10px;
        font-size: 1.08em;
        letter-spacing: 0.03em;
      }
      .legends-content {
        display: flex;
        flex-direction: row;
        flex-wrap: wrap;
        justify-content: space-between;
        gap: 24px;
        align-items: flex-end;
      }
      .legend {
        background: none;
        border: none;
        box-shadow: none;
        padding: 0;
        min-width: 220px;
        flex: 1 1 220px;
        display: flex;
        flex-direction: column;
        align-items: center;
      }
      .legend-title {
        font-size: 0.7em;
        font-weight: 600;
        color: #222;
        margin-bottom: 6px;
        text-align: center;
        letter-spacing: 0.01em;
      }
      .legend-bar {
        width: 100%;
        max-width: 420px;
        min-width: 160px;
        height: 18px;
        /* Remove border-radius for sharp edges */
        border-radius: 0;
        margin-bottom: 6px;
        position: relative;
        box-shadow: 0 1px 4px rgba(0,0,0,0.04);
        border: none; /* Remove border for seamless color */
        overflow: hidden;
        transition: max-width 0.2s;
        /* Remove background to avoid white showing through */
        background: none;
      }
      .legend-labels {
        display: flex;
        justify-content: space-between;
        width: 100%;
        max-width: 420px;
        min-width: 160px;
        font-size: 0.85em;
        color: #444;
        margin-top: 0;
        margin-bottom: 2px;
      }
      @media (max-width: 600px) {
        .legend-bar,
        .legend-labels {
          max-width: 180px;
        }
      }
      @media (min-width: 601px) and (max-width: 991px) {
        .legend-bar,
        .legend-labels {
          max-width: 300px;
        }
      }
      @media (min-width: 992px) {
        .legend-bar,
        .legend-labels {
          max-width: 420px;
        }
      }

      /* --- 5. Info Panel Styles --- */
      .info-panel h3,
      .info-panel h4 {
        font-size: 1.1em;
        color: #004d40;
        margin: 0 0 5px 0;
      }
      .info-panel h4 {
        font-size: 1em;
        color: #333;
        margin-top: 15px;
        border-top: 1px solid #eee;
        padding-top: 10px;
      }
      .info-panel p {
        margin: 5px 0;
        line-height: 1.5;
      }
      .info-panel .data-item {
        margin-bottom: 8px;
      }
      .info-panel .data-label {
        font-weight: 600;
        color: #444;
      }
      .info-panel .data-value {
        color: #111;
      }
      .placeholder-text {
        color: #777;
        font-style: italic;
      }

      /* --- 6. Footer --- */
      footer {
        text-align: center;
        padding: 15px;
        background-color: #e0e0e0;
        color: #555;
        font-size: 0.9em;
        margin-top: auto;
      }

      /* --- START: New Back Button Styles --- */
      .back-button-container {
        margin-top: 20px;
        padding-top: 15px;
        border-top: 1px solid #eee;
      }

      .back-button {
        display: block;
        width: 100%;
        padding: 12px 15px;
        background-color: #004d40;
        color: white;
        text-align: center;
        text-decoration: none;
        border-radius: 4px;
        font-weight: 600;
        font-size: 1em;
        border: none;
        cursor: pointer;
        transition: background-color 0.2s ease-in-out;
      }

      .back-button:hover,
      .back-button:focus {
        background-color: #00392e;
        color: white;
        text-decoration: none;
      }
      /* --- END: New Back Button Styles --- */

      /* --- 7. Media Queries for Larger Screens (Tablets & Desktops) --- */
      @media (min-width: 992px) {
        header {
          flex-direction: row;
          justify-content: space-between;
          align-items: center;
        }
        header h1 {
          font-size: 1.8em;
          order: 2;
          flex-grow: 1;
          text-align: center;
        }
        .header-logos-container {
          display: contents;
        }
        .header-logo {
          height: 50px;
          max-width: none;
        }
        img[alt="AIM AHEAD Logo"] {
          order: 1;
        }
        img[alt="RCMI Logo"] {
          order: 3;
        }

        .main-content {
          display: flex;
          padding: 20px;
          gap: 20px;
          align-items: stretch;
        }

        .sidebar {
          padding: 20px;
          margin-bottom: 0;
        }

        .left-sidebar.sidebar {
          flex: 0 0 300px;
          display: flex;
          flex-direction: column;
        }

        .map-container {
          flex-grow: 1;
          display: flex;
          flex-direction: column;
        }
        #map {
          flex-grow: 1;
          height: auto;
          min-height: 600px;
        }

        #legend-container {
          padding: 15px 0;
          width: 100%;
          flex-shrink: 0;
        }
        #legend-container > label {
          display: none;
        }
        .legends-content {
          justify-content: space-between; /* Desktop: Space between the two legend boxes */
          gap: 20px; /* Desktop: Gap between legend boxes */
        }
        .legend {
          flex-grow: 1;         /* Allow legend boxes to grow */
          flex-shrink: 1;       /* Allow them to shrink if needed */
          flex-basis: 0;        /* Distribute space based on flex-grow, effectively making them equal width */
          min-width: 250px;     /* Desktop: Prevent them from becoming too narrow, adjust as needed */
          /* max-width: none; /* Ensure no max-width limits them if previously set for desktop */
          margin-bottom: 0;
        }

        .map-container .right-sidebar.sidebar {
          width: 100%;
          margin-top: 20px;
        }

        .sidebar h2 {
          font-size: 1.4em;
        }
        .info-panel h3 {
          font-size: 1.2em;
        }
        .info-panel h4 {
          font-size: 1.1em;
        }

        .left-sidebar.sidebar .back-button-container {
          margin-top: auto;
        }
      }
    </style>
  </head>
  <body>
    {%include 'header.html'%}
    <div class="main-content">
      <div class="left-sidebar sidebar">
        <h2>Controls</h2>

        <div class="control-group">
          <label for="metric-select">Select Health Risk Indicator:</label>
          <select id="metric-select"></select>
          <div id="metric-description" class="metric-description-panel">
            <p class="placeholder-text">
              Select a health risk indicator to see its description.
            </p>
          </div>
        </div>

        <div class="control-group">
          <label for="sdoh-select"
            >Select SDoH Indicator (Municipality Outline):</label
          >
          <select id="sdoh-select"></select>
          <div id="sdoh-description" class="metric-description-panel">
            <p class="placeholder-text">
              Select an SDoH indicator to see its description.
            </p>
          </div>
        </div>

        <div class="back-button-container">
          <a href="{% url 'sdoh' %}" class="back-button">Back to SDoH Page</a>
        </div>
      </div>

      <div class="map-container">
        <div id="map"></div>

        <div id="legend-container">
          <label>Scale</label>
          <div class="legends-content">
            <div id="health-legend" class="legend">
              <!-- Health Risk Legend will be rendered here -->
            </div>
            <div id="sdoh-legend" class="legend">
              <!-- SDoH Legend will be rendered here -->
            </div>
          </div>
        </div>

        <div class="right-sidebar sidebar">
          <h2>Area Information</h2>
          <div id="info-panel" class="info-panel">
            <p class="placeholder-text">
              Click on a municipality on the map to see details.
            </p>
          </div>
        </div>
      </div>

    </div>

    <footer>
      <p>
        Data Source: Cardiovascular Risk (Provided), US Census Municipalities,
        ACS 5-Year Estimates (2020)
      </p>
      <p>Map created by Luis F. Velazquez Sosa © 2025</p>
    </footer>

    <script>
      // --- Data from Django context ---
      const geojsonDataString = `{{ geojson_data|safe }}`;
      const healthStatsDataString = `{{ health_stats_data|safe }}`;
      const sdohDataString = `{{ sdoh_data|safe }}`;
      const sdohVariableMapString = `{{ sdoh_variable_map_json|safe }}`;

      // --- Global Variables ---
      let map; // MapLibre map object
      let geojsonData;
      let healthStatsRawData;
      let healthStatsLookup = {};
      let sdohRawData;
      let sdohDataLookup = {};
      let sdohVariableMap = {};
      let currentHealthMetricKey = "AO_High";
      let currentSDoHMetricKey = "POS_MIN_DIST_ED";
      // let geojsonLayer; // No longer a single Leaflet layer object
      // let healthRiskCirclesLayerGroup = L.layerGroup(); // Replaced by MapLibre source/layer
      let selectedFeatureId = null; // For MapLibre feature state
      let hoveredFeatureId = null; // For MapLibre feature state

      const riskCalculationDescriptions = {
        "Risk of Coronary Heart Disease":
          "Coronary Heart Disease risk is often assessed using ratios like TC/HDL (Total Cholesterol to HDL). <br> - TC/HDL < 4.0: Low Risk <br> - TC/HDL 4.0-5.0: Moderate Risk <br> - TC/HDL > 5.0: High Risk",
        "Risk of Arterial Obstruction":
          "Arterial Obstruction risk can be indicated by LDL/HDL ratios. <br> - LDL/HDL < 2.5: Low Risk <br> - LDL/HDL 2.5-3.5: Moderate Risk <br> - LDL/HDL > 3.5: High Risk",
        "Risk of Heart Attack or Atherosclerosis":
          "Risk of Heart Attack or Atherosclerosis can be evaluated using Non-HDL Cholesterol levels. <br> - Non-HDL < 130 mg/dL: Low Risk <br> - Non-HDL 130-160 mg/dL: Moderate Risk <br> - Non-HDL > 160 mg/dL: High Risk",
      };

      try {
        geojsonData = JSON.parse(geojsonDataString);
      } catch (e) {
        console.error("GeoJSON Parse Error:", e);
        geojsonData = { type: "FeatureCollection", features: [] };
      }
      try {
        healthStatsRawData = JSON.parse(healthStatsDataString);
        healthStatsLookup = healthStatsRawData || {};
      } catch (e) {
        console.error("Health Stats Parse Error:", e);
        healthStatsLookup = {};
      }
      try {
        sdohRawData = JSON.parse(sdohDataString);
        if (Array.isArray(sdohRawData)) {
          sdohRawData.forEach((item) => {
            if (item.COUNTY && item.YEAR === 2020)
              sdohDataLookup[item.COUNTY] = item;
          });
        } else {
          console.error("SDoH data not array");
        }
      } catch (e) {
        console.error("SDoH Data Parse Error:", e);
      }
      try {
        sdohVariableMap = JSON.parse(sdohVariableMapString);
      } catch (e) {
        console.error("SDoH Map Parse Error:", e);
      }

      const GOOD_LOW_COLORS = [ "#ffffb2", "#fed976", "#feb24c", "#fd8d3c", "#fc4e2a", "#e31a1c", "#b10026"];
      const SDOH_COLORS = [ "#e0ecf4", "#bfd3e6", "#9ebcda", "#8c96c6", "#8c6bb1", "#88419d", "#6e016b", "#4d0042" ];

      const filteredHealthMetricConfigs = {
        CHD_High: { displayName: "Coronary Heart Disease", dataPath: ["Risk of Coronary Heart Disease", "percentages", "High"], type: "goodIsLow", breaks: [10, 11.5, 13, 14.5, 16, 17.5], colors: GOOD_LOW_COLORS, unit: "%", description: "Percentage of population at High Risk for Coronary Heart Disease. Higher percentage is worse."},
        AO_High: { displayName: "Arterial Obstruction", dataPath: ["Risk of Arterial Obstruction", "percentages", "High"], type: "goodIsLow", breaks: [15, 16, 17, 18, 19, 20], colors: GOOD_LOW_COLORS, unit: "%", description: "Percentage of population at High Risk for Arterial Obstruction. Higher percentage is worse."},
        HA_High: { displayName: "Heart Attack Risk", dataPath: ["Risk of Heart Attack or Atherosclerosis", "percentages", "High"], type: "goodIsLow", breaks: [5, 7, 9, 11, 12.5, 13.2], colors: GOOD_LOW_COLORS, unit: "%", description: "Percentage of population at High Risk for Heart Attack or Atherosclerosis. Higher percentage is worse."},
      };

      const sdohMetricConfigs = {
        ACS_PCT_UNINSURED: { type: "percentage", breaks: [4.0, 5.0, 6.3, 8.0, 10.1, 12.7, 16.0], colors: SDOH_COLORS, unit: "%" },
        ACS_PCT_LT_HS: { type: "percentage", breaks: [15.0, 18.0, 21.6, 26.0, 31.2, 37.5, 45.0], colors: SDOH_COLORS, unit: "%" },
        POS_MIN_DIST_ED: { type: "distance", breaks: [1.0, 1.6, 2.7, 4.5, 7.4, 12.1, 20.0], colors: SDOH_COLORS, unit: " mi" },
        ACS_PCT_HH_PUB_ASSIST: { type: "percentage", breaks: [25.0, 29.3, 34.4, 40.3, 47.3, 55.4, 65.0], colors: SDOH_COLORS, unit: "%" },
        ACS_PCT_INC50_BELOW17: { type: "percentage", breaks: [25.0, 29.3, 34.4, 40.3, 47.3, 55.4, 65.0], colors: SDOH_COLORS, unit: "%" },
        ACS_PCT_INC50_ABOVE65: { type: "percentage", breaks: [10.0, 12.6, 15.9, 20.0, 25.2, 31.7, 40.0], colors: SDOH_COLORS, unit: "%" },
        ACS_PCT_DISABLE: { type: "percentage", breaks: [10.0, 12.6, 15.9, 20.0, 25.2, 31.7, 40.0], colors: SDOH_COLORS, unit: "%" },
        ACS_PCT_NONVET_DISABLE_18_64: { type: "percentage", breaks: [10.0, 12.6, 15.9, 20.0, 25.2, 31.7, 40.0], colors: SDOH_COLORS, unit: "%" },
        ACS_PCT_VET_DISABLE_18_64: { type: "percentage", breaks: [10.0, 13.8, 19.1, 26.5, 36.6, 50.6, 70.0], colors: SDOH_COLORS, unit: "%" },
        HIFLD_MIN_DIST_UC: { type: "distance", breaks: [2.0, 3.0, 4.6, 7.1, 10.8, 16.4, 25.0], colors: SDOH_COLORS, unit: " mi" },
        POS_MIN_DIST_ALC: { type: "distance", breaks: [5.0, 7.1, 10.0, 14.1, 20.0, 28.3, 40.0], colors: SDOH_COLORS, unit: " mi" },
        ACS_TOT_CIVIL_EMPLOY_POP: { type: "count", breaks: [2500, 4754, 9040, 17192, 32692, 62167, 120000], colors: SDOH_COLORS, unit: "" },
        ACS_PCT_COLLEGE_ASSOCIATE_DGR: { type: "percentage", breaks: [10.0, 12.6, 15.9, 20.0, 25.2, 31.7, 40.0], colors: SDOH_COLORS, unit: "%" },
        ACS_PCT_BACHELOR_DGR: { type: "percentage", breaks: [5.0, 6.9, 9.6, 13.2, 18.3, 25.3, 35.0], colors: SDOH_COLORS, unit: "%" },
        ACS_PCT_GRADUATE_DGR: { type: "percentage", breaks: [1.0, 1.6, 2.5, 4.0, 6.3, 10.1, 16.0], colors: SDOH_COLORS, unit: "%" },
        ACS_PCT_HS_GRADUATE: { type: "percentage", breaks: [20.0, 23.3, 27.1, 31.6, 36.8, 42.9, 50.0], colors: SDOH_COLORS, unit: "%" },
        ACS_PCT_POSTHS_ED: { type: "percentage", breaks: [20.0, 24.0, 28.8, 34.6, 41.6, 50.0, 60.0], colors: SDOH_COLORS, unit: "%" },
        ACS_PCT_HEALTH_INC_BELOW137: { type: "percentage", breaks: [30.0, 36.0, 43.3, 52.0, 62.4, 74.9, 90.0], colors: SDOH_COLORS, unit: "%" },
        ACS_PCT_HEALTH_INC_138_199: { type: "percentage", breaks: [5.0, 6.9, 9.6, 13.2, 18.3, 25.3, 35.0], colors: SDOH_COLORS, unit: "%" },
        ACS_PCT_HEALTH_INC_200_399: { type: "percentage", breaks: [5.0, 6.9, 9.6, 13.2, 18.3, 25.3, 35.0], colors: SDOH_COLORS, unit: "%" },
        ACS_PCT_HEALTH_INC_ABOVE400: { type: "percentage", breaks: [1.0, 1.6, 2.7, 4.5, 7.4, 12.1, 20.0], colors: SDOH_COLORS, unit: "%" },
      };

      const healthMetricSelect = document.getElementById("metric-select");
      const healthMetricDescriptionPanel = document.getElementById("metric-description");
      const sdohSelect = document.getElementById("sdoh-select");
      const sdohDescriptionPanel = document.getElementById("sdoh-description");
      const healthLegendDiv = document.getElementById("health-legend");
      const sdohLegendDiv = document.getElementById("sdoh-legend");
      const infoPanel = document.getElementById("info-panel");
      
      // --- Helper Functions ---
      function getInitialMapZoom() {
        if (window.innerWidth <= 600) return 7.5; // Mobile: zoom
        return 8.5; // Desktop/tablet: default zoom (MapLibre zoom levels can feel different)
      }

      function getNestedHealthValue(healthData, dataPath) {
        if (!healthData || !dataPath || !Array.isArray(dataPath)) return null;
        let value = healthData;
        for (const key of dataPath) {
          if (value && typeof value === "object" && key in value) {
            value = value[key];
          } else { return null; }
        }
        return value;
      }
      
      function getHealthColor(value, metricKey) {
        const config = filteredHealthMetricConfigs[metricKey];
        if (!config || value === null || value === undefined || isNaN(value)) return "#E0E0E0"; // Default gray
        const { breaks, colors } = config;
        if (!breaks || !colors || breaks.length === 0 || colors.length === 0) return "#E0E0E0";
        if (colors.length < breaks.length + 1) return colors[colors.length - 1] || "#E0E0E0";
        for (let i = 0; i < breaks.length; i++) {
          if (value <= breaks[i]) return colors[i];
        }
        return colors[breaks.length]; // Corresponds to colors[colors.length - 1]
      }

      // Generates MapLibre 'step' expression for SDoH colors
      function getSDoHColorExpression(metricKey) {
          const config = sdohMetricConfigs[metricKey];
          if (!config || !config.breaks || !config.colors) {
              console.warn(`No config for SDoH metric: ${metricKey}`);
              return 'rgba(0,0,0,0)'; // Transparent or a default placeholder color
          }
          const { breaks, colors } = config;
          if (colors.length !== breaks.length + 1) {
              console.error(`SDoH Color/breaks mismatch for key: ${metricKey}. Colors: ${colors.length}, Breaks: ${breaks.length}`);
              return colors.length > 0 ? colors[colors.length - 1] : 'rgba(0,0,0,0)';
          }

          // Path to the SDoH value within the feature properties: feature.properties.sdoh[metricKey]
          const sDoHValueGetter = ['to-number', ['get', metricKey, ['get', 'sdoh']]];

          const stepExpression = ['step', sDoHValueGetter, colors[0]]; // Default color for values < breaks[0]
          for (let i = 0; i < breaks.length; i++) {
              stepExpression.push(breaks[i]);        // stop_input_i
              stepExpression.push(colors[i + 1]);    // output_i (color for range ending at breaks[i])
          }
          
          // Full expression to handle cases where sdoh data or specific metric might be missing/null
          return [
              'case',
              ['!', ['has', 'sdoh', ['properties']]], 'rgba(221,221,221,0.3)', // No 'sdoh' object in properties
              ['!', ['has', metricKey, ['get', 'sdoh']]], 'rgba(221,221,221,0.3)', // Metric key not in 'sdoh' object
              ['any', ['==', ['get', metricKey, ['get', 'sdoh']], null], ['==', ['typeof', ['get', metricKey, ['get', 'sdoh']]], 'undefined']], 'rgba(221,221,221,0.3)', // Value is null/undefined
              stepExpression // Otherwise, use the calculated step expression
          ];
      }


      function getHealthRiskCircleRadius(value, valueForMaxRadius) {
        const minRadius = 2, maxRadius = 12;
        if (value === null || value === undefined || isNaN(value) || value <= 0) return minRadius / 2;
        let radius = (valueForMaxRadius <= 0) ? minRadius : minRadius + (value / valueForMaxRadius) * (maxRadius - minRadius);
        return Math.max(minRadius / 2, Math.min(maxRadius, radius));
      }

      // Helper to get LngLatBounds of a feature for map.fitBounds
      function getFeatureLngLatBounds(feature) {
        const bounds = new maplibregl.LngLatBounds();
        const geom = feature.geometry;

        function processCoordinates(coords) {
            if (typeof coords[0] === 'number' && typeof coords[1] === 'number' && coords.length === 2) { // A single point [lng, lat]
                bounds.extend(coords);
            } else if (Array.isArray(coords)) { // An array of points or deeper nested arrays
                coords.forEach(c => processCoordinates(c));
            }
        }
        processCoordinates(geom.coordinates);
        return bounds;
      }
      
      // --- Data Preprocessing ---
      function preprocessGeojsonData() {
        if (!geojsonData || !geojsonData.features) return;
        geojsonData.features.forEach((feature, index) => {
          // Ensure each feature has a unique ID for feature state. Using NAME, assuming it's unique.
          // If NAME is not reliably unique, generate an index-based ID: feature.id = index;
          if (feature.properties && feature.properties.NAME) {
            feature.id = feature.properties.NAME; // MapLibre uses 'id' at the top level of the feature object
          } else {
            feature.id = index; // Fallback if NAME is missing
            if (feature.properties) feature.properties.NAME = `Unnamed Area ${index}`;
            else feature.properties = { NAME: `Unnamed Area ${index}` };
          }
          
          const municipalityName = feature.properties.NAME;
          feature.properties.healthData = healthStatsLookup[municipalityName] || null;
          feature.properties.sdoh = sdohDataLookup[municipalityName] || {}; // Embed SDoH data
        });
      }
      preprocessGeojsonData();


      // --- UI Population ---
      function populateSelect(selectElement, configObject, defaultKey) {
        selectElement.innerHTML = "";
        const sortedKeys = Object.keys(configObject).sort((a, b) => {
          const itemA = configObject[a]; const itemB = configObject[b];
          const stringA = typeof itemA === "object" && itemA?.displayName ? itemA.displayName : typeof itemA === "string" ? itemA : String(a);
          const stringB = typeof itemB === "object" && itemB?.displayName ? itemB.displayName : typeof itemB === "string" ? itemB : String(b);
          return stringA.localeCompare(stringB);
        });
        sortedKeys.forEach((key) => {
          if (selectElement.id === "sdoh-select") {
            const nonNumericSDoHKeys = ["YEAR", "COUNTYFIPS", "COUNTY", "STATE", "lon", "lat"];
            if (nonNumericSDoHKeys.includes(key) || !sdohMetricConfigs[key]) return;
          }
          const option = document.createElement("option");
          option.value = key;
          const item = configObject[key];
          option.textContent = typeof item === "object" && item?.displayName ? item.displayName : typeof item === "string" ? item : key;
          if (key === defaultKey) option.selected = true;
          selectElement.appendChild(option);
        });
      }
      populateSelect(healthMetricSelect, filteredHealthMetricConfigs, currentHealthMetricKey);
      populateSelect(sdohSelect, sdohVariableMap, currentSDoHMetricKey);

      function updateDescriptionPanel(panelElement, key, configMap, variableMap = null) {
        let description = "Description not available.";
        if (configMap && configMap[key]?.description) {
          description = configMap[key].description;
        } else if (variableMap && variableMap[key]) {
          description = variableMap[key];
        } else if (configMap && configMap[key]?.displayName) {
          description = configMap[key].displayName;
        }
        panelElement.innerHTML = description ? `<p>${description.replace(/\n/g, "<br>")}</p>` : '<p class="placeholder-text">Select an indicator.</p>';
      }
      updateDescriptionPanel(healthMetricDescriptionPanel, currentHealthMetricKey, filteredHealthMetricConfigs);
      updateDescriptionPanel(sdohDescriptionPanel, currentSDoHMetricKey, sdohMetricConfigs, sdohVariableMap);

      // --- Map Initialization & Layers ---
      map = new maplibregl.Map({
        container: "map",
        style: "https://demotiles.maplibre.org/style.json", // Basic style, replace with your preferred one
        center: [-66.25, 18.18], // Lng, Lat for Puerto Rico
        zoom: getInitialMapZoom(),
        minZoom: 7,
        maxZoom: 12,
        attributionControl: false, // We'll add a custom one
      });

      map.addControl(new maplibregl.NavigationControl(), 'top-right');
      map.addControl(new maplibregl.FullscreenControl(), 'top-right');
      map.addControl(new maplibregl.AttributionControl({
          customAttribution: 'Health Risk: Abartys Health | SDoH: ACS 2020 | Base Map: © OpenStreetMap contributors, © CARTO'
      }), 'bottom-right');


      map.on("load", () => {
        if (!geojsonData || !geojsonData.features || geojsonData.features.length === 0) {
            document.getElementById("map").innerHTML = "<p>Could not load map boundary data.</p>";
            return;
        }

        map.addSource("municipalities", {
          type: "geojson",
          data: geojsonData,
          promoteId: 'NAME' // Use NAME property as feature ID if available and unique
        });

        map.addLayer({
          id: "municipalities-fill",
          type: "fill",
          source: "municipalities",
          paint: {
            "fill-color": getSDoHColorExpression(currentSDoHMetricKey),
            "fill-opacity": [ // Slightly change opacity on hover/select
                'case',
                ['boolean', ['feature-state', 'select'], false], 0.9,
                ['boolean', ['feature-state', 'hover'], false], 0.75,
                0.6
            ]
          },
        });

        map.addLayer({
          id: "municipalities-outline",
          type: "line",
          source: "municipalities",
          paint: {
            "line-color": [
                'case',
                ['boolean', ['feature-state', 'select'], false], '#020c1a', // Darker for selected
                ['boolean', ['feature-state', 'hover'], false], '#051B35', // Dark for hover
                '#555' // Default
            ],
            "line-width": [
                'case',
                ['boolean', ['feature-state', 'select'], false], 3,
                ['boolean', ['feature-state', 'hover'], false], 2.5,
                1.5
            ]
          },
        });

        // Interactions for municipalities
        map.on("mousemove", "municipalities-fill", (e) => {
          map.getCanvas().style.cursor = "pointer";
          if (e.features.length > 0) {
            const currentFeatureId = e.features[0].id;
            if (hoveredFeatureId && hoveredFeatureId !== currentFeatureId) {
              map.setFeatureState({ source: "municipalities", id: hoveredFeatureId }, { hover: false });
            }
            hoveredFeatureId = currentFeatureId;
            map.setFeatureState({ source: "municipalities", id: hoveredFeatureId }, { hover: true });
          }
        });

        map.on("mouseleave", "municipalities-fill", () => {
          map.getCanvas().style.cursor = "";
          if (hoveredFeatureId) {
            map.setFeatureState({ source: "municipalities", id: hoveredFeatureId }, { hover: false });
          }
          hoveredFeatureId = null;
        });

        map.on("click", "municipalities-fill", (e) => {
          if (e.features.length > 0) {
            const clickedFeature = e.features[0];
            if (selectedFeatureId) {
              map.setFeatureState({ source: "municipalities", id: selectedFeatureId }, { select: false });
            }
            selectedFeatureId = clickedFeature.id;
            map.setFeatureState({ source: "municipalities", id: selectedFeatureId }, { select: true });
            
            map.fitBounds(getFeatureLngLatBounds(clickedFeature), { padding: 40, maxZoom:10 });
            updateInfoPanel(clickedFeature.properties);
          }
        });

        // Initialize health circles source and layer (data will be added by drawHealthRiskCircles)
        map.addSource('health-points', {
            type: 'geojson',
            data: { type: 'FeatureCollection', features: [] }
        });

        map.addLayer({
            id: 'health-circles',
            type: 'circle',
            source: 'health-points',
            paint: {
                'circle-radius': ['get', 'radiusForCircle'],
                'circle-color': ['get', 'colorForCircle'],
                'circle-stroke-width': 0.75,
                'circle-stroke-color': '#333333',
                'circle-opacity': 0.9
            }
        }, 'municipalities-outline'); // Draw circles on top of fills, potentially under outlines if needed, or on top of all municipality layers

        const healthCirclePopup = new maplibregl.Popup({
            closeButton: false,
            closeOnClick: false,
            anchor: 'bottom'
        });

        map.on('mouseenter', 'health-circles', (e) => {
            map.getCanvas().style.cursor = 'pointer';
            const coordinates = e.features[0].geometry.coordinates.slice();
            const props = e.features[0].properties;
            const healthConf = filteredHealthMetricConfigs[currentHealthMetricKey]; // Get current config for unit

            const description = `<b>${props.municipalityName}</b><br>${props.healthDisplayName}: ${parseFloat(props.healthRiskValue).toFixed(1)}${healthConf.unit || ""}`;

            while (Math.abs(e.lngLat.lng - coordinates[0]) > 180) {
                coordinates[0] += e.lngLat.lng > coordinates[0] ? 360 : -360;
            }
            healthCirclePopup.setLngLat(coordinates).setHTML(description).addTo(map);
        });

        map.on('mouseleave', 'health-circles', () => {
            map.getCanvas().style.cursor = '';
            healthCirclePopup.remove();
        });

        // Initial draws
        updateSDoHLegend(currentSDoHMetricKey);
        drawHealthRiskCircles(); // This will also update health legend
        updateInfoPanel(null); // Clear info panel
      });


      // --- Info Panel & Legends Update ---
      function updateInfoPanel(muniProps) {
        if (!muniProps?.NAME) {
          infoPanel.innerHTML = '<p class="placeholder-text">Click on a municipality for details.</p>';
          return;
        }
        const { NAME: municipalityName, healthData, sdoh: sdohData } = muniProps; // sdoh is now embedded
        let content = `<h3>Municipality: ${municipalityName}</h3>`;

        content += `<hr style="margin:10px 0;"><h4>SDoH Indicator (Outline)</h4>`;
        if (sdohData && Object.keys(sdohData).length > 0) {
          const sc = sdohMetricConfigs[currentSDoHMetricKey];
          const sv = sdohData[currentSDoHMetricKey];
          const sd = sdohVariableMap[currentSDoHMetricKey] || sc?.displayName || currentSDoHMetricKey;
          const sdv = (sv !== null && sv !== undefined && !isNaN(sv)) ? `${parseFloat(sv).toFixed(sc?.type === "percentage" ? 1 : sc?.type === "count" ? 0 : 2)}${sc?.unit || ""}` : "N/A";
          content += `<p><span class="data-label">${sd}:</span> <strong class="data-value">${sdv}</strong></p>`;
        } else {
          content += `<p>No SDoH data for "${currentSDoHMetricKey}" in ${municipalityName}.</p>`;
        }

        content += `<h4 style="margin-top:15px;">Cardiovascular Health Risk (Circles)</h4>`;
        if (healthData) {
          const currentHealthConfig = filteredHealthMetricConfigs[currentHealthMetricKey];
          if (currentHealthConfig && currentHealthConfig.dataPath) {
            const healthValue = getNestedHealthValue(healthData, currentHealthConfig.dataPath);
            const displayValue = (healthValue !== null && !isNaN(healthValue)) ? `${parseFloat(healthValue).toFixed(currentHealthConfig.unit === "%" ? 2 : 0)} ${currentHealthConfig.unit || ""}`: "N/A";
            content += `<p><span class="data-label">${currentHealthConfig.displayName}:</span> <strong class="data-value">${displayValue}</strong></p>`;
            const riskTypeKey = currentHealthConfig.dataPath[0];
            const calculationInfo = riskCalculationDescriptions[riskTypeKey];
            if (calculationInfo) content += `<p style="font-size:0.85em; margin-top:5px; color:#555;"><em><strong>Note:</strong> ${calculationInfo}</em></p>`;
            content += `<p style="margin-top:10px;"><small><i>Other risk levels for ${riskTypeKey}:</i></small></p>`;
            ["Low", "Moderate"].forEach(level => {
              const val = getNestedHealthValue(healthData, [riskTypeKey, "percentages", level]);
              const dispVal = (val !== null && !isNaN(val)) ? `${parseFloat(val).toFixed(2)}%` : "N/A";
              content += `<p style="font-size:0.9em;"><span class="data-label">% ${level} Risk:</span> <span class="data-value">${dispVal}</span></p>`;
            });
            const totalEval = getNestedHealthValue(healthData, [riskTypeKey, "total_evaluated"]);
            const totalEvalDisp = (totalEval !== null && !isNaN(totalEval)) ? `${parseFloat(totalEval).toLocaleString()}` : "N/A";
            const riskShortName = riskTypeKey.split(" ").length > 2 ? riskTypeKey.split(" ")[2] : riskTypeKey.split(" ")[0];
            content += `<p style="font-size:0.9em;"><span class="data-label">Total Evaluated (${riskShortName}):</span> <span class="data-value">${totalEvalDisp}</span></p>`;
          } else { content += `<p>Config for ${currentHealthMetricKey} incomplete.</p>`; }
        } else { content += `<p>No cardiovascular health data for ${municipalityName}.</p>`; }
        infoPanel.innerHTML = content;
      }

      function updateHealthLegend(metricKey, valueForMaxRadiusForLegend) { // Unchanged from original
        const config = filteredHealthMetricConfigs[metricKey];
        healthLegendDiv.innerHTML = "";
        if (!config || !config.colors || !config.colors.length || !config.breaks || !config.breaks.length) {
          healthLegendDiv.innerHTML = `<p>Health Risk legend N/A.</p>`; return;
        }
        if (config.colors.length < config.breaks.length + 1) {
          healthLegendDiv.innerHTML = `<p>Health legend config error.</p>`; return;
        }
        const { colors, breaks, unit, displayName } = config;
        let barWidth = healthLegendDiv.offsetWidth || 300; barWidth = Math.max(160, Math.min(barWidth, 420));
        let barSvg = `<svg class="legend-bar" width="${barWidth}" height="18" viewBox="0 0 ${barWidth} 18">`;
        const bandWidth = barWidth / colors.length;
        for (let i = 0; i < colors.length; i++) {
          barSvg += `<rect x="${i * bandWidth}" y="0" width="${bandWidth}" height="18" fill="${colors[i]}" />`;
        }
        barSvg += `</svg>`;
        let min = breaks[0], max = breaks[breaks.length - 1];
        let minLabel = `${min}${unit}`, maxLabel = `${max}${unit}`;
        let labelsHtml = `<div class="legend-labels"><span>${minLabel}</span><span>${maxLabel}+</span></div>`;
        healthLegendDiv.innerHTML = `<div class="legend-title">${displayName}</div>${barSvg}${labelsHtml}`;
      }

      function updateSDoHLegend(metricKey) { // Unchanged from original
        const config = sdohMetricConfigs[metricKey];
        const variableDesc = sdohVariableMap[metricKey] || metricKey;
        sdohLegendDiv.innerHTML = "";
        if (!config || !config.colors || !config.colors.length || !config.breaks || !config.breaks.length) {
          sdohLegendDiv.innerHTML = `<p>SDoH Legend N/A.</p>`; return;
        }
        if (config.colors.length < config.breaks.length + 1) {
          sdohLegendDiv.innerHTML = `<p>SDoH legend config error.</p>`; return;
        }
        let barWidth = sdohLegendDiv.offsetWidth || 300; barWidth = Math.max(160, Math.min(barWidth, 420));
        const { colors, breaks, unit } = config;
        let barSvg = `<svg class="legend-bar" width="${barWidth}" height="18" viewBox="0 0 ${barWidth} 18">`;
        const bandWidth = barWidth / colors.length;
        for (let i = 0; i < colors.length; i++) {
          barSvg += `<rect x="${i * bandWidth}" y="0" width="${bandWidth}" height="18" fill="${colors[i]}" />`;
        }
        barSvg += `</svg>`;
        let min = breaks[0], max = breaks[breaks.length - 1];
        let minLabel = `${min}${unit}`, maxLabel = `${max}${unit}`;
        let labelsHtml = `<div class="legend-labels"><span>${minLabel}</span><span>${maxLabel}+</span></div>`;
        sdohLegendDiv.innerHTML = `<div class="legend-title">${variableDesc}</div>${barSvg}${labelsHtml}`;
      }

      // --- Event Listeners for Selectors ---
      healthMetricSelect.addEventListener("change", function () {
        currentHealthMetricKey = this.value;
        drawHealthRiskCircles(); // This updates circles data and health legend
        updateDescriptionPanel(healthMetricDescriptionPanel, currentHealthMetricKey, filteredHealthMetricConfigs);
        if (selectedFeatureId) { // Update info panel if a feature is selected
            const features = map.querySourceFeatures('municipalities', {
                sourceLayer: 'municipalities-fill', // Not needed if source isn't vector tiles
                filter: ['==', ['id'], selectedFeatureId]
            });
            if (features.length > 0) updateInfoPanel(features[0].properties);
        } else {
            updateInfoPanel(null);
        }
      });

      sdohSelect.addEventListener("change", function () {
        currentSDoHMetricKey = this.value;
        if (!sdohMetricConfigs[currentSDoHMetricKey]) {
          console.error(`Config missing for SDoH key: ${currentSDoHMetricKey}`);
          sdohLegendDiv.innerHTML = `<p>Viz config missing.</p>`;
          // Potentially set a default non-data-driven color if config is missing
          // map.setPaintProperty('municipalities-fill', 'fill-color', '#ccc'); 
        } else {
            map.setPaintProperty('municipalities-fill', 'fill-color', getSDoHColorExpression(currentSDoHMetricKey));
            updateSDoHLegend(currentSDoHMetricKey);
        }
        updateDescriptionPanel(sdohDescriptionPanel, currentSDoHMetricKey, sdohMetricConfigs, sdohVariableMap);
        if (selectedFeatureId) { // Update info panel
             const features = map.querySourceFeatures('municipalities', {
                filter: ['==', ['id'], selectedFeatureId]
            });
            if (features.length > 0) updateInfoPanel(features[0].properties);
        }
      });

      // --- Health Risk Circles Drawing Logic ---
      function drawHealthRiskCircles() {
        if (!map || !map.getSource('health-points')) {
            console.warn("Map or health-points source not ready for drawing circles.");
            return;
        }
        const healthConfig = filteredHealthMetricConfigs[currentHealthMetricKey];
        if (!healthConfig || !healthConfig.dataPath) {
          console.error("Health config/dataPath missing.");
          updateHealthLegend(currentHealthMetricKey, 30); // Use a default max value for legend
          return;
        }

        let V_max_for_scaling = 0;
        let validValuesFound = false;
        geojsonData.features.forEach((feature) => { // Iterate preprocessed geojsonData
          const healthDataForMuni = feature.properties.healthData;
          if (healthDataForMuni) {
            const val = getNestedHealthValue(healthDataForMuni, healthConfig.dataPath);
            if (val !== null && !isNaN(val) && val > 0) {
              V_max_for_scaling = Math.max(V_max_for_scaling, val);
              validValuesFound = true;
            }
          }
        });
        if (!validValuesFound || V_max_for_scaling <= 0) {
          V_max_for_scaling = (healthConfig.breaks && healthConfig.breaks.length > 0) ? healthConfig.breaks[healthConfig.breaks.length - 1] * 1.2 : 30;
          if (V_max_for_scaling <= 0) V_max_for_scaling = 30; // Absolute fallback
        }

        const circleFeatures = [];
        geojsonData.features.forEach((feature) => {
          const { NAME: municipalityName, healthData: healthDataForMuni, sdoh: sdohMuniData } = feature.properties;
          if (municipalityName && healthDataForMuni && sdohMuniData && typeof sdohMuniData.lat === "number" && typeof sdohMuniData.lon === "number") {
            const healthRiskValue = getNestedHealthValue(healthDataForMuni, healthConfig.dataPath);
            const radius = getHealthRiskCircleRadius(healthRiskValue, V_max_for_scaling);
            const color = getHealthColor(healthRiskValue, currentHealthMetricKey);
            
            circleFeatures.push({
              type: 'Feature',
              geometry: { type: 'Point', coordinates: [sdohMuniData.lon, sdohMuniData.lat] }, // Lng, Lat
              properties: {
                municipalityName: municipalityName,
                healthRiskValue: healthRiskValue, // Store raw value for tooltips, etc.
                healthDisplayName: healthConfig.displayName,
                colorForCircle: color,    // Pre-calculated color for styling
                radiusForCircle: radius, // Pre-calculated radius
              }
            });
          }
        });
        
        map.getSource('health-points').setData({ type: 'FeatureCollection', features: circleFeatures });
        updateHealthLegend(currentHealthMetricKey, V_max_for_scaling);
      }

    </script>
  </body>
</html>