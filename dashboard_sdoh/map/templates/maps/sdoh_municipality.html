{% load static %}
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link
      rel="apple-touch-icon"
      sizes="57x57"
      href="{% static 'apple-icon-57x57.png' %}"
    />
    <link
      rel="apple-touch-icon"
      sizes="60x60"
      href="{% static 'apple-icon-60x60.png' %}"
    />
    <link
      rel="apple-touch-icon"
      sizes="72x72"
      href="{% static 'apple-icon-72x72.png' %}"
    />
    <link
      rel="apple-touch-icon"
      sizes="76x76"
      href="{% static 'apple-icon-76x76.png' %}"
    />
    <link
      rel="apple-touch-icon"
      sizes="114x114"
      href="{% static 'apple-icon-114x114.png' %}"
    />
    <link
      rel="apple-touch-icon"
      sizes="120x120"
      href="{% static 'apple-icon-120x120.png' %}"
    />
    <link
      rel="apple-touch-icon"
      sizes="144x144"
      href="{% static 'apple-icon-144x144.png' %}"
    />
    <link
      rel="apple-touch-icon"
      sizes="152x152"
      href="{% static 'apple-icon-152x152.png' %}"
    />
    <link
      rel="apple-touch-icon"
      sizes="180x180"
      href="{% static 'apple-icon-180x180.png' %}"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="192x192"
      href="{% static 'android-icon-192x192.png' %}"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="32x32"
      href="{% static 'favicon-32x32.png' %}"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="96x96"
      href="{% static 'favicon-96x96.png' %}"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="16x16"
      href="{% static 'favicon-16x16.png' %}"
    />
    <link rel="manifest" href="{% static 'manifest.json' %}" />
    <meta name="msapplication-TileColor" content="#ffffff" />
    <meta name="msapplication-TileImage" content="/ms-icon-144x144.png" />
    <meta name="theme-color" content="#ffffff" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Puerto Rico Health Indicators Map</title>
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
      integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
      crossorigin=""
    />
    <script
      src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
      integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
      crossorigin=""
    ></script>

    <style>
      /* --- 1. Global & Basic Resets --- */
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Helvetica, Arial, sans-serif;
        background-color: #f4f7f6;
        color: #333;
        display: flex;
        flex-direction: column;
        min-height: 100vh;
        line-height: 1.6;
      }

      /* --- 2. Header --- */
      header {
        background-color: rgb(60, 0, 88);
        color: white;
        padding: 15px 20px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 10px;
      }
      header h1 {
        margin: 0;
        font-size: 1.5em;
        text-align: center;
        order: 1;
      }
      .header-logos-container {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 20px;
        order: 2;
      }
      .header-logo {
        height: 40px;
        max-width: 120px;
        object-fit: contain;
      }

      /* --- 3. Main Content Area (Mobile First) --- */
      .main-content {
        flex-grow: 1;
        padding: 15px;
      }

      .sidebar,
      .map-container {
        background-color: #ffffff;
        padding: 15px;
        border-radius: 8px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        width: 100%;
        margin-bottom: 20px;
      }
      .main-content > *:last-child {
        margin-bottom: 0;
      }
      .sidebar {
        overflow-y: auto;
        overflow-x: hidden;
      }

      .map-container {
        display: flex;
        flex-direction: column;
      }

      #map {
        width: 100%;
        height: 400px; /* Mobile height */
        border-radius: 8px;
        border: 1px solid #ddd;
        flex-shrink: 0;
      }

      .sidebar h2 {
        margin-top: 0;
        font-size: 1.3em;
        color: #004d40;
        border-bottom: 2px solid #b2dfdb;
        padding-bottom: 10px;
        margin-bottom: 15px;
      }
      .control-group {
        margin-bottom: 20px;
      }
      .control-group label {
        display: block;
        margin-bottom: 8px;
        font-weight: 600;
        color: #555;
      }
      .control-group select {
        width: 100%;
        padding: 10px;
        border-radius: 4px;
        border: 1px solid #ccc;
        background-color: #fff;
        font-size: 0.95em;
      }
      .metric-description-panel {
        padding: 10px;
        background-color: #f9f9f9;
        border: 1px solid #eee;
        border-radius: 4px;
        font-size: 0.9em;
        color: #333;
        min-height: 60px;
        margin-top: 5px;
      }
      .metric-description-panel p {
        margin: 0 0 5px 0;
      }
      .metric-description-panel strong {
        color: #004d40;
      }

      /* --- 4. Legend Styles (Redesigned) --- */
      #legend-container {
        margin-top: 15px;
        padding: 16px 0 8px 0;
        border-top: 1px solid #e0e0e0;
        width: 100%;
        background: #fafbfc;
        border-radius: 0 0 8px 8px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.03);
      }
      #legend-container > label {
        display: block;
        text-align: center;
        font-weight: 700;
        color: #333;
        margin-bottom: 10px;
        font-size: 1.08em;
        letter-spacing: 0.03em;
      }
      .legends-content {
        display: flex;
        flex-direction: row;
        flex-wrap: wrap;
        justify-content: space-between;
        gap: 24px;
        align-items: flex-end;
      }
      .legend {
        background: none;
        border: none;
        box-shadow: none;
        padding: 0;
        min-width: 220px;
        flex: 1 1 220px;
        display: flex;
        flex-direction: column;
        align-items: center;
      }
      .legend-title {
        font-size: 0.7em;
        font-weight: 600;
        color: #222;
        margin-bottom: 6px;
        text-align: center;
        letter-spacing: 0.01em;
      }
      .legend-bar {
        width: 100%;
        max-width: 420px;
        min-width: 160px;
        height: 18px;
        /* Remove border-radius for sharp edges */
        border-radius: 0;
        margin-bottom: 6px;
        position: relative;
        box-shadow: 0 1px 4px rgba(0,0,0,0.04);
        border: none; /* Remove border for seamless color */
        overflow: hidden;
        transition: max-width 0.2s;
        /* Remove background to avoid white showing through */
        background: none;
      }
      .legend-labels {
        display: flex;
        justify-content: space-between;
        width: 100%;
        max-width: 420px;
        min-width: 160px;
        font-size: 0.85em;
        color: #444;
        margin-top: 0;
        margin-bottom: 2px;
      }
      @media (max-width: 600px) {
        .legend-bar,
        .legend-labels {
          max-width: 180px;
        }
      }
      @media (min-width: 601px) and (max-width: 991px) {
        .legend-bar,
        .legend-labels {
          max-width: 300px;
        }
      }
      @media (min-width: 992px) {
        .legend-bar,
        .legend-labels {
          max-width: 420px;
        }
      }

      /* --- 5. Info Panel Styles --- */
      .info-panel h3,
      .info-panel h4 {
        font-size: 1.1em;
        color: #004d40;
        margin: 0 0 5px 0;
      }
      .info-panel h4 {
        font-size: 1em;
        color: #333;
        margin-top: 15px;
        border-top: 1px solid #eee;
        padding-top: 10px;
      }
      .info-panel p {
        margin: 5px 0;
        line-height: 1.5;
      }
      .info-panel .data-item {
        margin-bottom: 8px;
      }
      .info-panel .data-label {
        font-weight: 600;
        color: #444;
      }
      .info-panel .data-value {
        color: #111;
      }
      .placeholder-text {
        color: #777;
        font-style: italic;
      }

      /* --- 6. Footer --- */
      footer {
        text-align: center;
        padding: 15px;
        background-color: #e0e0e0;
        color: #555;
        font-size: 0.9em;
        margin-top: auto;
      }

      /* --- START: New Back Button Styles --- */
      .back-button-container {
        margin-top: 20px;
        padding-top: 15px;
        border-top: 1px solid #eee;
      }

      .back-button {
        display: block;
        width: 100%;
        padding: 12px 15px;
        background-color: #004d40;
        color: white;
        text-align: center;
        text-decoration: none;
        border-radius: 4px;
        font-weight: 600;
        font-size: 1em;
        border: none;
        cursor: pointer;
        transition: background-color 0.2s ease-in-out;
      }

      .back-button:hover,
      .back-button:focus {
        background-color: #00392e;
        color: white;
        text-decoration: none;
      }
      /* --- END: New Back Button Styles --- */

      /* --- 7. Media Queries for Larger Screens (Tablets & Desktops) --- */
      @media (min-width: 992px) {
        header {
          flex-direction: row;
          justify-content: space-between;
          align-items: center;
        }
        header h1 {
          font-size: 1.8em;
          order: 2;
          flex-grow: 1;
          text-align: center;
        }
        .header-logos-container {
          display: contents;
        }
        .header-logo {
          height: 50px;
          max-width: none;
        }
        img[alt="AIM AHEAD Logo"] {
          order: 1;
        }
        img[alt="RCMI Logo"] {
          order: 3;
        }

        .main-content {
          display: flex;
          padding: 20px;
          gap: 20px;
          align-items: stretch;
        }

        .sidebar {
          padding: 20px;
          margin-bottom: 0;
        }

        .left-sidebar.sidebar {
          flex: 0 0 300px;
          display: flex;
          flex-direction: column;
        }

        .map-container {
          flex-grow: 1;
          display: flex;
          flex-direction: column;
        }
        #map {
          flex-grow: 1;
          height: auto;
          min-height: 600px;
        }

        #legend-container {
          padding: 15px 0;
          width: 100%;
          flex-shrink: 0;
        }
        #legend-container > label {
          display: none;
        }
        .legends-content {
          justify-content: space-between; /* Desktop: Space between the two legend boxes */
          gap: 20px; /* Desktop: Gap between legend boxes */
        }
        .legend {
          flex-grow: 1;         /* Allow legend boxes to grow */
          flex-shrink: 1;       /* Allow them to shrink if needed */
          flex-basis: 0;        /* Distribute space based on flex-grow, effectively making them equal width */
          min-width: 250px;     /* Desktop: Prevent them from becoming too narrow, adjust as needed */
          /* max-width: none; /* Ensure no max-width limits them if previously set for desktop */
          margin-bottom: 0;
        }

        .map-container .right-sidebar.sidebar {
          width: 100%;
          margin-top: 20px;
        }

        .sidebar h2 {
          font-size: 1.4em;
        }
        .info-panel h3 {
          font-size: 1.2em;
        }
        .info-panel h4 {
          font-size: 1.1em;
        }

        .left-sidebar.sidebar .back-button-container {
          margin-top: auto;
        }
      }
    </style>
  </head>
  <body>
    {%include 'header.html'%}
    <div class="main-content">
      <div class="left-sidebar sidebar">
        <h2>Controls</h2>

        <div class="control-group">
          <label for="metric-select">Select Health Risk Indicator:</label>
          <select id="metric-select"></select>
          <div id="metric-description" class="metric-description-panel">
            <p class="placeholder-text">
              Select a health risk indicator to see its description.
            </p>
          </div>
        </div>

        <div class="control-group">
          <label for="sdoh-select"
            >Select SDoH Indicator (Municipality Outline):</label
          >
          <select id="sdoh-select"></select>
          <div id="sdoh-description" class="metric-description-panel">
            <p class="placeholder-text">
              Select an SDoH indicator to see its description.
            </p>
          </div>
        </div>

        {% comment %} <div class="back-button-container">
          <a href="{% url 'sdoh' %}" class="back-button">Back to SDoH Page</a>
        </div> {% endcomment %}
      </div>

      <div class="map-container">
        <div id="map"></div>

        <div id="legend-container">
          <label>Scale</label>
          <div class="legends-content">
            <div id="health-legend" class="legend">
              <!-- Health Risk Legend will be rendered here -->
            </div>
            <div id="sdoh-legend" class="legend">
              <!-- SDoH Legend will be rendered here -->
            </div>
          </div>
        </div>

        <div class="right-sidebar sidebar">
          <h2>Area Information</h2>
          <div id="info-panel" class="info-panel">
            <p class="placeholder-text">
              Click on a municipality on the map to see details.
            </p>
          </div>
        </div>
      </div>

    </div>

    <footer>
      <p>
        Data Source: Cardiovascular Risk (Provided), US Census Municipalities,
        ACS 5-Year Estimates (2020)
      </p>
      <p>Map created by Luis F. Velazquez Sosa © 2025</p>
    </footer>

    <script>
      // --- Data from Django context ---
      const geojsonDataString = `{{ geojson_data|safe }}`;
      const healthStatsDataString = `{{ health_stats_data|safe }}`;
      const sdohDataString = `{{ sdoh_data|safe }}`;
      const sdohVariableMapString = `{{ sdoh_variable_map_json|safe }}`;

      // --- Global Variables ---
      let geojsonData;
      let healthStatsRawData;
      let healthStatsLookup = {};
      let sdohRawData;
      let sdohDataLookup = {};
      let sdohVariableMap = {};
      let currentHealthMetricKey = "AO_High";
      let currentSDoHMetricKey = "POS_MIN_DIST_ED";
      let geojsonLayer;
      let healthRiskCirclesLayerGroup = L.layerGroup();
      let selectedLayer = null;

      const riskCalculationDescriptions = {
        "Risk of Coronary Heart Disease":
          "Coronary Heart Disease risk is often assessed using ratios like TC/HDL (Total Cholesterol to HDL). <br> - TC/HDL < 4.0: Low Risk <br> - TC/HDL 4.0-5.0: Moderate Risk <br> - TC/HDL > 5.0: High Risk",
        "Risk of Arterial Obstruction":
          "Arterial Obstruction risk can be indicated by LDL/HDL ratios. <br> - LDL/HDL < 2.5: Low Risk <br> - LDL/HDL 2.5-3.5: Moderate Risk <br> - LDL/HDL > 3.5: High Risk",
        "Risk of Heart Attack or Atherosclerosis":
          "Risk of Heart Attack or Atherosclerosis can be evaluated using Non-HDL Cholesterol levels. <br> - Non-HDL < 130 mg/dL: Low Risk <br> - Non-HDL 130-160 mg/dL: Moderate Risk <br> - Non-HDL > 160 mg/dL: High Risk",
      };

      try {
        geojsonData = JSON.parse(geojsonDataString);
      } catch (e) {
        console.error("GeoJSON Parse Error:", e);
        geojsonData = { type: "FeatureCollection", features: [] };
      }
      try {
        healthStatsRawData = JSON.parse(healthStatsDataString);
        healthStatsLookup = healthStatsRawData || {};
      } catch (e) {
        console.error("Health Stats Parse Error:", e);
        healthStatsLookup = {};
      }
      try {
        sdohRawData = JSON.parse(sdohDataString);
        if (Array.isArray(sdohRawData)) {
          sdohRawData.forEach((item) => {
            if (item.COUNTY && item.YEAR === 2020)
              sdohDataLookup[item.COUNTY] = item;
          });
        } else {
          console.error("SDoH data not array");
        }
      } catch (e) {
        console.error("SDoH Data Parse Error:", e);
      }
      try {
        sdohVariableMap = JSON.parse(sdohVariableMapString);
      } catch (e) {
        console.error("SDoH Map Parse Error:", e);
      }

      const GOOD_LOW_COLORS = [
        "#ffffb2",
        "#fed976",
        "#feb24c",
        "#fd8d3c",
        "#fc4e2a",
        "#e31a1c",
        "#b10026"
      ];
      const SDOH_COLORS = [ // Should be 8 colors if breaks length is 7
        "#e0ecf4",
        "#bfd3e6",
        "#9ebcda",
        "#8c96c6",
        "#8c6bb1",
        "#88419d",
        "#6e016b",
        "#4d0042", 
      ];

      const filteredHealthMetricConfigs = {
        CHD_High: {
          displayName: "Coronary Heart Disease",
          dataPath: ["Risk of Coronary Heart Disease", "percentages", "High"],
          type: "goodIsLow",
          breaks: [10, 11.5, 13, 14.5, 16, 17.5], // 6 breaks for 7 colors
          colors: GOOD_LOW_COLORS,
          unit: "%",
          description:
            "Percentage of population at High Risk for Coronary Heart Disease. Higher percentage is worse.",
        },
        AO_High: {
          displayName: "Arterial Obstruction",
          dataPath: ["Risk of Arterial Obstruction", "percentages", "High"],
          type: "goodIsLow",
          breaks: [15, 16, 17, 18, 19, 20], // 6 breaks for 7 colors
          colors: GOOD_LOW_COLORS,
          unit: "%",
          description:
            "Percentage of population at High Risk for Arterial Obstruction. Higher percentage is worse.",
        },
        HA_High: {
          displayName: "Heart Attack Risk",
          dataPath: [
            "Risk of Heart Attack or Atherosclerosis",
            "percentages",
            "High",
          ],
          type: "goodIsLow",
          breaks: [5, 7, 9, 11, 12.5, 13.2], // 6 breaks for 7 colors
          colors: GOOD_LOW_COLORS,
          unit: "%",
          description:
            "Percentage of population at High Risk for Heart Attack or Atherosclerosis. Higher percentage is worse.",
        },
      };

      const sdohMetricConfigs = { // Ensure colors.length = breaks.length + 1 for each
        ACS_PCT_UNINSURED: {
          type: "percentage", breaks: [4.0, 5.0, 6.3, 8.0, 10.1, 12.7, 16.0], colors: SDOH_COLORS, unit: "%",
        },
        ACS_PCT_LT_HS: {
          type: "percentage", breaks: [15.0, 18.0, 21.6, 26.0, 31.2, 37.5, 45.0], colors: SDOH_COLORS, unit: "%",
        },
        // ... (ensure all SDoH configs have appropriate breaks and colors array lengths)
        POS_MIN_DIST_ED: {
          type: "distance", breaks: [1.0, 1.6, 2.7, 4.5, 7.4, 12.1, 20.0], colors: SDOH_COLORS, unit: " mi",
        },
         // Add other SDoH configs here, ensuring `colors.length` is `breaks.length + 1`
        ACS_PCT_HH_PUB_ASSIST: { type: "percentage", breaks: [25.0, 29.3, 34.4, 40.3, 47.3, 55.4, 65.0], colors: SDOH_COLORS, unit: "%" },
        ACS_PCT_INC50_BELOW17: { type: "percentage", breaks: [25.0, 29.3, 34.4, 40.3, 47.3, 55.4, 65.0], colors: SDOH_COLORS, unit: "%" },
        ACS_PCT_INC50_ABOVE65: { type: "percentage", breaks: [10.0, 12.6, 15.9, 20.0, 25.2, 31.7, 40.0], colors: SDOH_COLORS, unit: "%" },
        ACS_PCT_DISABLE: { type: "percentage", breaks: [10.0, 12.6, 15.9, 20.0, 25.2, 31.7, 40.0], colors: SDOH_COLORS, unit: "%" },
        ACS_PCT_NONVET_DISABLE_18_64: { type: "percentage", breaks: [10.0, 12.6, 15.9, 20.0, 25.2, 31.7, 40.0], colors: SDOH_COLORS, unit: "%" },
        ACS_PCT_VET_DISABLE_18_64: { type: "percentage", breaks: [10.0, 13.8, 19.1, 26.5, 36.6, 50.6, 70.0], colors: SDOH_COLORS, unit: "%" },
        HIFLD_MIN_DIST_UC: { type: "distance", breaks: [2.0, 3.0, 4.6, 7.1, 10.8, 16.4, 25.0], colors: SDOH_COLORS, unit: " mi" },
        POS_MIN_DIST_ALC: { type: "distance", breaks: [5.0, 7.1, 10.0, 14.1, 20.0, 28.3, 40.0], colors: SDOH_COLORS, unit: " mi" },
        ACS_TOT_CIVIL_EMPLOY_POP: { type: "count", breaks: [2500, 4754, 9040, 17192, 32692, 62167, 120000], colors: SDOH_COLORS, unit: "" },
        ACS_PCT_COLLEGE_ASSOCIATE_DGR: { type: "percentage", breaks: [10.0, 12.6, 15.9, 20.0, 25.2, 31.7, 40.0], colors: SDOH_COLORS, unit: "%" },
        ACS_PCT_BACHELOR_DGR: { type: "percentage", breaks: [5.0, 6.9, 9.6, 13.2, 18.3, 25.3, 35.0], colors: SDOH_COLORS, unit: "%" },
        ACS_PCT_GRADUATE_DGR: { type: "percentage", breaks: [1.0, 1.6, 2.5, 4.0, 6.3, 10.1, 16.0], colors: SDOH_COLORS, unit: "%" },
        ACS_PCT_HS_GRADUATE: { type: "percentage", breaks: [20.0, 23.3, 27.1, 31.6, 36.8, 42.9, 50.0], colors: SDOH_COLORS, unit: "%" },
        ACS_PCT_POSTHS_ED: { type: "percentage", breaks: [20.0, 24.0, 28.8, 34.6, 41.6, 50.0, 60.0], colors: SDOH_COLORS, unit: "%" },
        ACS_PCT_HEALTH_INC_BELOW137: { type: "percentage", breaks: [30.0, 36.0, 43.3, 52.0, 62.4, 74.9, 90.0], colors: SDOH_COLORS, unit: "%" },
        ACS_PCT_HEALTH_INC_138_199: { type: "percentage", breaks: [5.0, 6.9, 9.6, 13.2, 18.3, 25.3, 35.0], colors: SDOH_COLORS, unit: "%" },
        ACS_PCT_HEALTH_INC_200_399: { type: "percentage", breaks: [5.0, 6.9, 9.6, 13.2, 18.3, 25.3, 35.0], colors: SDOH_COLORS, unit: "%" },
        ACS_PCT_HEALTH_INC_ABOVE400: { type: "percentage", breaks: [1.0, 1.6, 2.7, 4.5, 7.4, 12.1, 20.0], colors: SDOH_COLORS, unit: "%" },
      };

      // --- Responsive map zoom ---
      function getInitialMapZoom() {
        if (window.innerWidth <= 600) {
          return 8; // Mobile: zoom 8
        }
        return 10; // Desktop/tablet: default zoom
      }

      const map = L.map("map").setView([18.18, -66.25], getInitialMapZoom());
      L.tileLayer(
        "https://{s}.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}{r}.png",
        {
          attribution:
            "© OpenStreetMap contributors © CARTO | Health Risk: Abartys Health | SDoH: ACS 2020",
          subdomains: "abcd",
          minZoom: 8,
          maxZoom: 11,
        }
      ).addTo(map);

      map.createPane("healthRiskPane");
      map.getPane("healthRiskPane").style.zIndex = 650;
      map.getPane("healthRiskPane").style.pointerEvents = "none";
      healthRiskCirclesLayerGroup.addTo(map);
      if (map.getPane("tooltipPane")) {
        map.getPane("tooltipPane").style.zIndex = 670;
      }

      const healthMetricSelect = document.getElementById("metric-select");
      const healthMetricDescriptionPanel =
        document.getElementById("metric-description");
      const sdohSelect = document.getElementById("sdoh-select");
      const sdohDescriptionPanel = document.getElementById("sdoh-description");
      const healthLegendDiv = document.getElementById("health-legend");
      const sdohLegendDiv = document.getElementById("sdoh-legend");
      const infoPanel = document.getElementById("info-panel");

      function getNestedHealthValue(healthData, dataPath) {
        if (!healthData || !dataPath || !Array.isArray(dataPath)) return null;
        let value = healthData;
        for (const key of dataPath) {
          if (value && typeof value === "object" && key in value) {
            value = value[key];
          } else {
            return null;
          }
        }
        return value;
      }

      function populateSelect(selectElement, configObject, defaultKey) {
        selectElement.innerHTML = "";
        const sortedKeys = Object.keys(configObject).sort((a, b) => {
          const itemA = configObject[a];
          const itemB = configObject[b];
          const stringA =
            typeof itemA === "object" && itemA?.displayName
              ? itemA.displayName
              : typeof itemA === "string"
              ? itemA
              : String(a);
          const stringB =
            typeof itemB === "object" && itemB?.displayName
              ? itemB.displayName
              : typeof itemB === "string"
              ? itemB
              : String(b);
          return stringA.localeCompare(stringB);
        });
        sortedKeys.forEach((key) => {
          if (selectElement.id === "sdoh-select") {
            const nonNumericSDoHKeys = [
              "YEAR", "COUNTYFIPS", "COUNTY", "STATE", "lon", "lat",
            ];
            if (nonNumericSDoHKeys.includes(key) || !sdohMetricConfigs[key]) return;
          }
          const option = document.createElement("option");
          option.value = key;
          const item = configObject[key];
          option.textContent =
            typeof item === "object" && item?.displayName
              ? item.displayName
              : typeof item === "string"
              ? item
              : key;
          if (key === defaultKey) option.selected = true;
          selectElement.appendChild(option);
        });
      }
      populateSelect( healthMetricSelect, filteredHealthMetricConfigs, currentHealthMetricKey );
      populateSelect(sdohSelect, sdohVariableMap, currentSDoHMetricKey);

      function updateDescriptionPanel( panelElement, key, configMap, variableMap = null ) {
        let description = "Description not available.";
        if (configMap && configMap[key]?.description) {
          description = configMap[key].description;
        } else if (variableMap && variableMap[key]) {
          description = variableMap[key];
        } else if (configMap && configMap[key]?.displayName) {
          description = configMap[key].displayName;
        }
        panelElement.innerHTML = description
          ? `<p>${description.replace(/\n/g, "<br>")}</p>`
          : '<p class="placeholder-text">Select an indicator.</p>';
      }
      updateDescriptionPanel( healthMetricDescriptionPanel, currentHealthMetricKey, filteredHealthMetricConfigs );
      updateDescriptionPanel( sdohDescriptionPanel, currentSDoHMetricKey, sdohMetricConfigs, sdohVariableMap );

      if (geojsonData?.features && Object.keys(healthStatsLookup).length > 0) {
        geojsonData.features.forEach((feature) => {
          const municipalityName = feature.properties.NAME;
          if (municipalityName) {
            feature.properties.healthData = healthStatsLookup[municipalityName] || null;
          } else {
            feature.properties.healthData = null;
          }
        });
      } else {
        console.warn("GeoJSON features or healthStatsLookup is missing/empty.");
      }

      function getHealthColor(value, metricKey) {
        const config = filteredHealthMetricConfigs[metricKey];
        if (!config || value === null || value === undefined || isNaN(value)) return "#E0E0E0";
        const { breaks, colors } = config;
        if (!breaks || !colors || breaks.length === 0 || colors.length === 0) return "#E0E0E0";
        if (colors.length < breaks.length + 1) return colors[colors.length - 1] || "#E0E0E0";
        for (let i = 0; i < breaks.length; i++) {
          if (value <= breaks[i]) return colors[i];
        }
        return colors[breaks.length];
      }

      function getSDoHColor(value, metricKey) {
        const config = sdohMetricConfigs[metricKey];
        if (!config || value === null || value === undefined || isNaN(value)) return "transparent";
        const { breaks, colors } = config;
        if (!breaks || !colors || breaks.length === 0 || colors.length === 0) return "#DDDDDD";
        if (colors.length < breaks.length + 1) return colors[colors.length - 1] || "#DDDDDD";
        for (let i = 0; i < breaks.length; i++) {
          if (value <= breaks[i]) return colors[i] || "#DDDDDD";
        }
        return colors[breaks.length] || colors[colors.length - 1] || "#DDDDDD";
      }

      function styleHealthLayer(feature) {
        const municipalityName = feature.properties.NAME;
        const sdohMuniData = sdohDataLookup[municipalityName];
        let sdohValue = null;
        if (sdohMuniData) {
          sdohValue = sdohMuniData[currentSDoHMetricKey];
        }
        return {
          fillColor: getSDoHColor(sdohValue, currentSDoHMetricKey),
          weight: 1.5, opacity: 1, color: "#555", fillOpacity: 0.9,
        };
      }

      function getHealthRiskCircleRadius(value, valueForMaxRadius) {
        const minRadius = 2, maxRadius = 12;
        if (value === null || value === undefined || isNaN(value) || value <= 0) return minRadius / 2;
        let radius = (valueForMaxRadius <= 0) ? minRadius : minRadius + (value / valueForMaxRadius) * (maxRadius - minRadius);
        return Math.max(minRadius / 2, Math.min(maxRadius, radius));
      }

      function highlightFeature(e) {
        const layer = e.target;
        if (layer !== selectedLayer) layer.setStyle({ weight: 3, color: "#051B35", fillOpacity: 0.8 });
        if (!L.Browser.ie && !L.Browser.opera && !L.Browser.edge) {
          if (layer !== selectedLayer) layer.bringToFront();
        }
      }

      function resetHighlight(e) {
        if (e.target !== selectedLayer) geojsonLayer.resetStyle(e.target);
      }

      function selectFeature(e) {
        const layer = e.target;
        if (selectedLayer && selectedLayer !== layer) {
          try { geojsonLayer.resetStyle(selectedLayer); } catch (error) { console.warn("Error resetting style:", error); }
        }
        map.fitBounds(layer.getBounds().pad(0.1));
        layer.setStyle({ weight: 4, color: "#020c1a", dashArray: "", fillOpacity: 0.9 });
        layer.bringToFront();
        selectedLayer = layer;
        updateInfoPanel(layer.feature.properties);
      }

      function onEachFeature(feature, layer) {
        layer.on({ mouseover: highlightFeature, mouseout: resetHighlight, click: selectFeature });
      }

      function updateInfoPanel(muniProps) {
        if (!muniProps?.NAME) {
          infoPanel.innerHTML = '<p class="placeholder-text">Click on a municipality for details.</p>';
          return;
        }
        const { NAME: municipalityName, healthData } = muniProps;
        const sdohData = sdohDataLookup[municipalityName] || null;
        let content = `<h3>Municipality: ${municipalityName}</h3>`;

        content += `<hr style="margin:10px 0;"><h4>SDoH Indicator (Outline)</h4>`;
        if (sdohData) {
          const sc = sdohMetricConfigs[currentSDoHMetricKey];
          const sv = sdohData[currentSDoHMetricKey];
          const sd = sdohVariableMap[currentSDoHMetricKey] || sc?.displayName || currentSDoHMetricKey;
          const sdv = (sv !== null && !isNaN(sv)) ? `${parseFloat(sv).toFixed(sc?.type === "percentage" ? 1 : sc?.type === "count" ? 0 : 2)}${sc?.unit || ""}` : "N/A";
          content += `<p><span class="data-label">${sd}:</span> <strong class="data-value">${sdv}</strong></p>`;
        } else {
          content += `<p>No SDoH data for "${currentSDoHMetricKey}" in ${municipalityName}.</p>`;
        }

        content += `<h4 style="margin-top:15px;">Cardiovascular Health Risk (Circles)</h4>`;
        if (healthData) {
          const currentHealthConfig = filteredHealthMetricConfigs[currentHealthMetricKey];
          if (currentHealthConfig && currentHealthConfig.dataPath) {
            const healthValue = getNestedHealthValue(healthData, currentHealthConfig.dataPath);
            const displayValue = (healthValue !== null && !isNaN(healthValue)) ? `${parseFloat(healthValue).toFixed(currentHealthConfig.unit === "%" ? 2 : 0)} ${currentHealthConfig.unit || ""}`: "N/A";
            content += `<p><span class="data-label">${currentHealthConfig.displayName}:</span> <strong class="data-value">${displayValue}</strong></p>`;
            const riskTypeKey = currentHealthConfig.dataPath[0];
            const calculationInfo = riskCalculationDescriptions[riskTypeKey];
            if (calculationInfo) content += `<p style="font-size:0.85em; margin-top:5px; color:#555;"><em><strong>Note:</strong> ${calculationInfo}</em></p>`;
            content += `<p style="margin-top:10px;"><small><i>Other risk levels for ${riskTypeKey}:</i></small></p>`;
            ["Low", "Moderate"].forEach(level => {
              const val = getNestedHealthValue(healthData, [riskTypeKey, "percentages", level]);
              const dispVal = (val !== null && !isNaN(val)) ? `${parseFloat(val).toFixed(2)}%` : "N/A";
              content += `<p style="font-size:0.9em;"><span class="data-label">% ${level} Risk:</span> <span class="data-value">${dispVal}</span></p>`;
            });
            const totalEval = getNestedHealthValue(healthData, [riskTypeKey, "total_evaluated"]);
            const totalEvalDisp = (totalEval !== null && !isNaN(totalEval)) ? `${parseFloat(totalEval).toLocaleString()}` : "N/A";
            const riskShortName = riskTypeKey.split(" ").length > 2 ? riskTypeKey.split(" ")[2] : riskTypeKey.split(" ")[0];
            content += `<p style="font-size:0.9em;"><span class="data-label">Total Evaluated (${riskShortName}):</span> <span class="data-value">${totalEvalDisp}</span></p>`;
          } else {
            content += `<p>Config for ${currentHealthMetricKey} incomplete.</p>`;
          }
        } else {
          content += `<p>No cardiovascular health data for ${municipalityName}.</p>`;
        }
        infoPanel.innerHTML = content;
      }

      function updateHealthLegend(metricKey, valueForMaxRadiusForLegend) {
        const config = filteredHealthMetricConfigs[metricKey];
        healthLegendDiv.innerHTML = "";

        if (!config || !config.colors || !config.colors.length || !config.breaks || !config.breaks.length) {
          healthLegendDiv.innerHTML = `<p>Health Risk legend N/A.</p>`;
          return;
        }
        if (config.colors.length < config.breaks.length + 1) {
          healthLegendDiv.innerHTML = `<p>Health legend config error.</p>`;
          return;
        }

        const { colors, breaks, unit, displayName } = config;
        // Responsive bar width
        let barWidth = healthLegendDiv.offsetWidth || 300;
        barWidth = Math.max(160, Math.min(barWidth, 420));
        let barSvg = `<svg class="legend-bar" width="${barWidth}" height="18" viewBox="0 0 ${barWidth} 18">`;
        const bandWidth = barWidth / colors.length;
        for (let i = 0; i < colors.length; i++) {
          barSvg += `<rect x="${i * bandWidth}" y="0" width="${bandWidth}" height="18" fill="${colors[i]}" />`;
        }
        barSvg += `</svg>`;

        // Min/Max labels (less text)
        let min = breaks[0], max = breaks[breaks.length - 1];
        let minLabel = `${min}${unit}`, maxLabel = `${max}${unit}`;
        let labelsHtml = `<div class="legend-labels"><span>${minLabel}</span><span>${maxLabel}+</span></div>`;

        healthLegendDiv.innerHTML = `
          <div class="legend-title">${displayName}</div>
          ${barSvg}
          ${labelsHtml}
        `;
      }

      function updateSDoHLegend(metricKey) {
        const config = sdohMetricConfigs[metricKey];
        const variableDesc = sdohVariableMap[metricKey] || metricKey;
        sdohLegendDiv.innerHTML = "";

        if (!config || !config.colors || !config.colors.length || !config.breaks || !config.breaks.length) {
          sdohLegendDiv.innerHTML = `<p>SDoH Legend N/A.</p>`;
          return;
        }
        if (config.colors.length < config.breaks.length + 1) {
          sdohLegendDiv.innerHTML = `<p>SDoH legend config error.</p>`;
          return;
        }

        // Responsive bar width
        let barWidth = sdohLegendDiv.offsetWidth || 300;
        barWidth = Math.max(160, Math.min(barWidth, 420));
        const { colors, breaks, unit } = config;
        let barSvg = `<svg class="legend-bar" width="${barWidth}" height="18" viewBox="0 0 ${barWidth} 18">`;
        const bandWidth = barWidth / colors.length;
        for (let i = 0; i < colors.length; i++) {
          barSvg += `<rect x="${i * bandWidth}" y="0" width="${bandWidth}" height="18" fill="${colors[i]}" />`;
        }
        barSvg += `</svg>`;

        // Min/Max labels (less text)
        let min = breaks[0], max = breaks[breaks.length - 1];
        let minLabel = `${min}${unit}`, maxLabel = `${max}${unit}`;
        let labelsHtml = `<div class="legend-labels"><span>${minLabel}</span><span>${maxLabel}+</span></div>`;

        sdohLegendDiv.innerHTML = `
          <div class="legend-title">${variableDesc}</div>
          ${barSvg}
          ${labelsHtml}
        `;
      }


      healthMetricSelect.addEventListener("change", function () {
        currentHealthMetricKey = this.value;
        drawHealthRiskCircles();
        updateDescriptionPanel( healthMetricDescriptionPanel, currentHealthMetricKey, filteredHealthMetricConfigs );
        if (selectedLayer) updateInfoPanel(selectedLayer.feature.properties);
        else updateInfoPanel(null);
      });

      sdohSelect.addEventListener("change", function () {
        currentSDoHMetricKey = this.value;
        if (!sdohMetricConfigs[currentSDoHMetricKey]) {
          console.error(`Config missing for SDoH key: ${currentSDoHMetricKey}`);
          sdohLegendDiv.innerHTML = `<p>Viz config missing.</p>`;
          if (geojsonLayer) geojsonLayer.setStyle(styleHealthLayer);
          updateDescriptionPanel( sdohDescriptionPanel, currentSDoHMetricKey, null, sdohVariableMap );
          return;
        }
        if (geojsonLayer) geojsonLayer.setStyle(styleHealthLayer);
        updateSDoHLegend(currentSDoHMetricKey);
        updateDescriptionPanel( sdohDescriptionPanel, currentSDoHMetricKey, sdohMetricConfigs, sdohVariableMap );
        if (selectedLayer) updateInfoPanel(selectedLayer.feature.properties);
      });

      if (geojsonData?.features?.length > 0) {
        geojsonLayer = L.geoJson(geojsonData, {
          style: styleHealthLayer,
          onEachFeature: onEachFeature,
        }).addTo(map);
      } else {
        document.getElementById("map").innerHTML = "<p>Could not load map boundary data.</p>";
      }

      function drawHealthRiskCircles() {
        healthRiskCirclesLayerGroup.clearLayers();
        const healthConfig = filteredHealthMetricConfigs[currentHealthMetricKey];
        if (!healthConfig || !healthConfig.dataPath) {
          console.error("Health config/dataPath missing.");
          updateHealthLegend(currentHealthMetricKey, 30);
          return;
        }

        let V_max_for_scaling = 0;
        let validValuesFound = false;
        geojsonData.features.forEach((feature) => {
          const healthDataForMuni = feature.properties.healthData;
          if (healthDataForMuni) {
            const val = getNestedHealthValue( healthDataForMuni, healthConfig.dataPath );
            if (val !== null && !isNaN(val) && val > 0) {
              V_max_for_scaling = Math.max(V_max_for_scaling, val);
              validValuesFound = true;
            }
          }
        });

        if (!validValuesFound || V_max_for_scaling <= 0) {
          V_max_for_scaling = (healthConfig.breaks && healthConfig.breaks.length > 0) ? healthConfig.breaks[healthConfig.breaks.length - 1] * 1.2 : 30;
          if (V_max_for_scaling <= 0) V_max_for_scaling = 30;
        }

        geojsonData.features.forEach((feature) => {
          const { NAME: municipalityName, healthData: healthDataForMuni } = feature.properties;
          const sdohMuniData = sdohDataLookup[municipalityName];
          if ( municipalityName && healthDataForMuni && sdohMuniData && typeof sdohMuniData.lat === "number" && typeof sdohMuniData.lon === "number" ) {
            const healthRiskValue = getNestedHealthValue( healthDataForMuni, healthConfig.dataPath );
            const radius = getHealthRiskCircleRadius( healthRiskValue, V_max_for_scaling );
            const color = getHealthColor( healthRiskValue, currentHealthMetricKey );
            const displayValue = (healthRiskValue !== null && !isNaN(healthRiskValue)) ? `${parseFloat(healthRiskValue).toFixed(1)}${healthConfig.unit || ""}` : "N/A";
            const circle = L.circleMarker( [sdohMuniData.lat, sdohMuniData.lon], {
                radius: radius, fillColor: color, color: "#333333", weight: 0.75,
                opacity: 0.8, fillOpacity: 0.9, pane: "healthRiskPane",
              }
            );
            circle.bindTooltip( `<b>${municipalityName}</b><br>${healthConfig.displayName}: ${displayValue}`, { sticky: true } );
            healthRiskCirclesLayerGroup.addLayer(circle);
          }
        });
        updateHealthLegend(currentHealthMetricKey, V_max_for_scaling);
      }

      updateSDoHLegend(currentSDoHMetricKey);
      drawHealthRiskCircles();
      updateInfoPanel(null);
    </script>
  </body>
</html>