{% load static %}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="apple-touch-icon" sizes="57x57" href="{% static 'apple-icon-57x57.png' %}">
    <link rel="apple-touch-icon" sizes="60x60" href="{% static 'apple-icon-60x60.png' %}">
    <link rel="apple-touch-icon" sizes="72x72" href="{% static 'apple-icon-72x72.png' %}">
    <link rel="apple-touch-icon" sizes="76x76" href="{% static 'apple-icon-76x76.png' %}">
    <link rel="apple-touch-icon" sizes="114x114" href="{% static 'apple-icon-114x114.png' %}">
    <link rel="apple-touch-icon" sizes="120x120" href="{% static 'apple-icon-120x120.png' %}">
    <link rel="apple-touch-icon" sizes="144x144" href="{% static 'apple-icon-144x144.png' %}">
    <link rel="apple-touch-icon" sizes="152x152" href="{% static 'apple-icon-152x152.png' %}">
    <link rel="apple-touch-icon" sizes="180x180" href="{% static 'apple-icon-180x180.png' %}">
    <link rel="icon" type="image/png" sizes="192x192" href="{% static 'android-icon-192x192.png' %}">
    <link rel="icon" type="image/png" sizes="32x32" href="{% static 'favicon-32x32.png' %}">
    <link rel="icon" type="image/png" sizes="96x96" href="{% static 'favicon-96x96.png' %}">
    <link rel="icon" type="image/png" sizes="16x16" href="{% static 'favicon-16x16.png' %}">
    <link rel="manifest" href="{% static 'manifest.json' %}">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="/ms-icon-144x144.png">
    <meta name="theme-color" content="#ffffff">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Puerto Rico Health Indicators Map</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
     integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
     crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
     integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
     crossorigin=""></script>
    
  <style>
    /* --- 1. Global & Basic Resets --- */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
        Helvetica, Arial, sans-serif;
      background-color: #f4f7f6;
      color: #333;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      line-height: 1.6;
    }

    /* --- 2. Header --- */
    header {
      background-color: rgb(60, 0, 88);
      color: white;
      padding: 15px 20px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }
    header h1 {
      margin: 0;
      font-size: 1.5em;
      text-align: center;
      order: 1;
    }
    .header-logos-container {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 20px;
      order: 2;
    }
    .header-logo {
      height: 40px;
      max-width: 120px;
      object-fit: contain;
    }

    /* --- 3. Main Content Area (Mobile First) --- */
    .main-content {
      flex-grow: 1;
      padding: 15px;
    }

    .sidebar,
    .map-container {
      background-color: #ffffff;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
      width: 100%;
      margin-bottom: 20px;
    }
    .main-content > *:last-child {
      margin-bottom: 0;
    }
    .sidebar {
      overflow-y: auto; /* Allows vertical scrolling if content is taller */
      overflow-x: hidden; /* Prevents horizontal scrolling */
    }

    .map-container {
      display: flex; /* Make it a flex container */
      flex-direction: column; /* Stack map and legends vertically */
    }

    #map {
      width: 100%;
      height: 400px; /* Mobile height */
      border-radius: 8px;
      border: 1px solid #ddd;
      flex-shrink: 0;
    }

    .sidebar h2 {
      margin-top: 0;
      font-size: 1.3em;
      color: #004d40;
      border-bottom: 2px solid #b2dfdb;
      padding-bottom: 10px;
      margin-bottom: 15px;
    }
    .control-group {
      margin-bottom: 20px;
    }
    .control-group label {
      display: block;
      margin-bottom: 8px;
      font-weight: 600;
      color: #555;
    }
    .control-group select {
      width: 100%;
      padding: 10px;
      border-radius: 4px;
      border: 1px solid #ccc;
      background-color: #fff;
      font-size: 0.95em;
    }
    .metric-description-panel {
      padding: 10px;
      background-color: #f9f9f9;
      border: 1px solid #eee;
      border-radius: 4px;
      font-size: 0.9em;
      color: #333;
      min-height: 60px;
      margin-top: 5px;
    }
    .metric-description-panel p {
      margin: 0 0 5px 0;
    }
    .metric-description-panel strong {
      color: #004d40;
    }

    /* --- 4. Legend Styles --- */
    #legend-container {
      margin-top: 15px;
      padding: 10px 0;
      border-top: 1px solid #e0e0e0;
      width: 100%;
    }
    #legend-container > label {
      display: block;
      text-align: center;
      font-weight: 600;
      color: #333;
      margin-bottom: 10px;
      font-size: 1.1em;
    }
    .legends-content {
      display: flex;
      flex-direction: row;
      flex-wrap: wrap;
      justify-content: space-around;
      gap: 10px;
    }

    .legend {
      line-height: 1.4;
      color: #555;
      padding: 8px;
      background-color: #fdfdfd;
      border-radius: 4px;
      border: 1px solid #eee;
      min-width: calc(50% - 10px);
      box-sizing: border-box;
    }

    .legend h5 {
      font-size: 0.9em;
      color: #333;
      margin: 0 0 6px 0;
      font-weight: 600;
      border-bottom: 1px solid #eee;
      padding-bottom: 3px;
    }
    .legend i {
      width: 16px;
      height: 16px;
      float: left;
      margin-right: 6px;
      border-radius: 3px;
      border: 1px solid rgba(0, 0, 0, 0.1);
    }
    .legend span {
      display: block;
      margin-bottom: 4px;
      clear: left;
      font-size: 0.85em;
    }
    .legend .legend-circle {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      display: inline-block;
      margin-right: 6px;
      vertical-align: middle;
      border: 1px solid rgba(0, 0, 0, 0.2);
    }
    .legend .legend-circle-label {
      display: inline-block;
      vertical-align: middle;
      font-size: 0.85em;
    }

    /* --- 5. Info Panel Styles --- */
    .info-panel h3,
    .info-panel h4 {
      font-size: 1.1em;
      color: #004d40;
      margin: 0 0 5px 0;
    }
    .info-panel h4 {
      font-size: 1em;
      color: #333;
      margin-top: 15px;
      border-top: 1px solid #eee;
      padding-top: 10px;
    }
    .info-panel p {
      margin: 5px 0;
      line-height: 1.5;
    }
    .info-panel .data-item {
      margin-bottom: 8px;
    }
    .info-panel .data-label {
      font-weight: 600;
      color: #444;
    }
    .info-panel .data-value {
      color: #111;
    }
    .placeholder-text {
      color: #777;
      font-style: italic;
    }

    /* --- 6. Footer --- */
    footer {
      text-align: center;
      padding: 15px;
      background-color: #e0e0e0;
      color: #555;
      font-size: 0.9em;
      margin-top: auto;
    }

    /* --- 7. Media Queries for Larger Screens (Tablets & Desktops) --- */
    @media (min-width: 992px) {
      header {
        flex-direction: row;
        justify-content: space-between;
        align-items: center;
      }
      header h1 {
        font-size: 1.8em;
        order: 2;
        flex-grow: 1;
        text-align: center;
      }
      .header-logos-container {
        display: contents;
      }
      .header-logo {
        height: 50px;
        max-width: none;
      }
      img[alt="AIM AHEAD Logo"] {
        order: 1;
      }
      img[alt="RCMI Logo"] {
        order: 3;
      }

      .main-content {
        display: flex;
        padding: 20px;
        gap: 20px;
        align-items: stretch;
      }
      .sidebar,
      .map-container {
        width: auto;
        margin-bottom: 0;
        padding: 20px;
      }
      .left-sidebar {
        flex: 0 0 300px;
      }
      .right-sidebar {
        flex: 0 0 350px;
      }
      .sidebar {
        display: flex;
        flex-direction: column;
      }

      .map-container {
        flex-grow: 1;
        display: flex;
        flex-direction: column;
      }
      #map {
        flex-grow: 1;
        height: auto;
        min-height: 500px;
      }

      #legend-container {
        display: flex;
        flex-direction: row;
        justify-content: space-around;
        gap: 20px;
        margin-top: 20px;
        padding: 15px 0;
        width: 100%;
        flex-shrink: 0;
      }
      #legend-container > label {
        display: none;
      }
      .legend {
        flex: 1;
        max-width: 48%;
        margin-bottom: 0;
      }

      .sidebar h2 {
        font-size: 1.4em;
      }
      .info-panel h3 {
        font-size: 1.2em;
      }
      .info-panel h4 {
        font-size: 1.1em;
      }
    }
    /* --- START: New Back Button Styles --- */
    .back-button-container {
      margin-top: 20px; /* Default spacing for mobile, below other controls */
      padding-top: 15px; /* Space above the button, below the border */
      border-top: 1px solid #eee; /* Visual separator from controls above */
    }

    .back-button {
      display: block; /* Take full width of its container */
      width: 100%;
      padding: 12px 15px; /* Slightly more padding for better click target */
      background-color: #004d40; /* Consistent theme color (matches h2) */
      color: white;
      text-align: center;
      text-decoration: none; /* Remove underline from anchor */
      border-radius: 4px; /* Consistent with other form elements */
      font-weight: 600;
      font-size: 1em; /* Slightly larger font for prominence */
      border: none; /* Remove default anchor/button border */
      cursor: pointer;
      transition: background-color 0.2s ease-in-out;
    }

    .back-button:hover,
    .back-button:focus {
      background-color: #00392e; /* Darker shade for hover/focus */
      color: white; /* Ensure text color remains white */
      text-decoration: none; /* Ensure no underline on hover/focus */
    }
    /* --- END: New Back Button Styles --- */

    /* Inside @media (min-width: 992px) block */
    /* --- START: Desktop specific style for Back Button --- */
    .left-sidebar.sidebar .back-button-container {
      /* Target specifically for desktop layout */
      margin-top: auto; /* Pushes this container to the bottom of the flex parent (.left-sidebar) */
    }
    /* --- END: Desktop specific style for Back Button --- */
  </style>
</head>
{% include "header.html"%}
<div class="main-content">
  <div class="left-sidebar sidebar">
    <h2>Controls</h2>

    <div class="control-group">
      <label for="metric-select">Select Health Indicator (ZIP Code):</label>
      <select id="metric-select"></select>
      <div id="metric-description" class="metric-description-panel">
        <p class="placeholder-text">
          Select a health indicator to see its description.
        </p>
      </div>
    </div>

    <div class="control-group">
      <label for="sdoh-select">Select SDoH Indicator (Municipality):</label>
      <select id="sdoh-select"></select>
      <div id="sdoh-description" class="metric-description-panel">
        <p class="placeholder-text">
          Select an SDoH indicator to see its description.
        </p>
      </div>
    </div>
    <!-- ****** NEW BACK BUTTON SECTION ****** -->
    <div class="back-button-container">
      <a href="{% url 'sdoh' %}" class="back-button">Back to SDoH Page</a>
    </div>
    <!-- ****** END NEW BACK BUTTON SECTION ****** -->
  </div>

  <div class="map-container">
    <div id="map"></div>

    <!-- Legends container is NOW a direct child of map-container, AFTER the map -->
    <div id="legend-container">
      <!-- Optional general title for legends -->
      <!-- <label>Legends:</label> -->
      <div id="health-legend" class="legend">
        <p class="placeholder-text">Select a health indicator for legend.</p>
      </div>
      <div id="sdoh-legend" class="legend">
        <p class="placeholder-text">Select an SDoH indicator for legend.</p>
      </div>
    </div>
  </div>

  <div class="right-sidebar sidebar">
    <h2>Area Information</h2>
    <div id="info-panel" class="info-panel">
      <p class="placeholder-text">
        Click on a ZIP code area on the map to see details.
      </p>
    </div>
  </div>
</div>

<footer>
  <p>
    Data Source: Abartys Health, US Census ZCTA, ACS 5-Year Estimates (2020)
  </p>
  <p>Map created by Luis F. Velazquez Sosa © 2025</p>
</footer>

<script>
  // --- Data from Django context ---
  const geojsonDataString = `{{ geojson_data|safe }}`;
  const healthStatsDataString = `{{ health_stats_data|safe }}`;
  const sdohDataString = `{{ sdoh_data|safe }}`;
  const sdohVariableMapString = `{{ sdoh_variable_map_json|safe }}`;
  const zipToMuniMapString = `{{ zip_to_muni_map_json|safe }}`;

  // --- Global Variables ---
  let geojsonData;
  let healthStatsRawData;
  let healthStatsLookup = {};
  let sdohRawData;
  let sdohDataLookup = {};
  let sdohVariableMap = {};
  let zipToMuniMap = {};
  let currentHealthMetricKey = "composite_risk_score_mean";
  let currentSDoHMetricKey = "ACS_PCT_UNINSURED";
  let geojsonLayer;
  let sdohLayerGroup = L.layerGroup(); // Initialize LayerGroup
  let selectedLayer = null;

  // --- Parse Data (Keep as is) ---
  try {
    geojsonData = JSON.parse(geojsonDataString);
  } catch (e) {
    console.error("GeoJSON Parse Error:", e);
    geojsonData = { type: "FeatureCollection", features: [] };
  }
  try {
    healthStatsRawData = JSON.parse(healthStatsDataString);
    if (Array.isArray(healthStatsRawData)) {
      healthStatsRawData.forEach((item) => {
        if (item.postal) healthStatsLookup[item.postal] = item;
      });
    } else {
      console.error("Health stats not array");
    }
  } catch (e) {
    console.error("Health Stats Parse Error:", e);
  }
  try {
    sdohRawData = JSON.parse(sdohDataString);
    if (Array.isArray(sdohRawData)) {
      sdohRawData.forEach((item) => {
        if (item.COUNTY && item.YEAR === 2020)
          sdohDataLookup[item.COUNTY] = item;
      });
    } else {
      console.error("SDoH data not array");
    }
  } catch (e) {
    console.error("SDoH Data Parse Error:", e);
  }
  try {
    sdohVariableMap = JSON.parse(sdohVariableMapString);
  } catch (e) {
    console.error("SDoH Map Parse Error:", e);
  }
  try {
    zipToMuniMap = JSON.parse(zipToMuniMapString);
  } catch (e) {
    console.error("Zip Map Parse Error:", e);
  }

  // --- Color Palettes & Configs (Keep as is) ---
  const GOOD_HIGH_COLORS = [
    "#E7080C",
    "#DF5E1D",
    "#FFC300",
    "#39D834",
    "#15D886",
  ];
  const GOOD_LOW_COLORS = [
    "#15D886",
    "#39D834",
    "#FFC300",
    "#DF5E1D",
    "#E7080C",
  ];
  const NEUTRAL_COLORS = [
    "#f7fcfd",
    "#e0ecf4",
    "#bfd3e6",
    "#9ebcda",
    "#8c96c6",
    "#8c6bb1",
    "#88419d",
    "#6e016b",
  ];
  const SDOH_COLORS = [
    "#feedde",
    "#fdd0a2",
    "#fdae6b",
    "#fd8d3c",
    "#f16913",
    "#d94801",
    "#a63603",
    "#7f2704",
  ];

  // Health Metric Configs (Keep as is)
  const healthMetricConfigs = {
    composite_risk_score_mean: {
      displayName: "Composite Risk Score (Mean)",
      dataKey: "composite_risk_score_mean",
      type: "goodIsLow",
      breaks: [0.5, 0.75, 1.0, 1.25],
      colors: GOOD_LOW_COLORS,
      unit: "score",
      description:
        "Average composite risk score (0-4). Calculated based on LDL>160, HDL<40, TG>150, TC/HDL≥5. Lower is better.",
    },
    composite_risk_score_median: {
      displayName: "Composite Risk Score (Median)",
      dataKey: "composite_risk_score_median",
      type: "goodIsLow",
      breaks: [0.5, 0.75, 1.0, 1.25],
      colors: GOOD_LOW_COLORS,
      unit: "score",
      description: "Median composite risk score (0-4). Lower is better.",
    },
    ldl_value_mean: {
      displayName: "Avg. LDL (Mean)",
      dataKey: "ldl_value_mean",
      type: "goodIsLow",
      breaks: [100, 130, 160, 190],
      colors: GOOD_LOW_COLORS,
      unit: "mg/dL",
      description:
        "Average LDL ('bad') Cholesterol. High Risk: > 160. Lower is better.",
    },
    ldl_value_median: {
      displayName: "Median LDL",
      dataKey: "ldl_value_median",
      type: "goodIsLow",
      breaks: [100, 130, 160, 190],
      colors: GOOD_LOW_COLORS,
      unit: "mg/dL",
      description: "Median LDL Cholesterol. Lower is better.",
    },
    hdl_value_mean: {
      displayName: "Avg. HDL (Mean)",
      dataKey: "hdl_value_mean",
      type: "goodIsHigh",
      breaks: [30, 40, 50, 60],
      colors: GOOD_HIGH_COLORS,
      unit: "mg/dL",
      description:
        "Average HDL ('good') Cholesterol. Low Risk: < 40. Higher is better.",
    },
    hdl_value_median: {
      displayName: "Median HDL",
      dataKey: "hdl_value_median",
      type: "goodIsHigh",
      breaks: [30, 40, 50, 60],
      colors: GOOD_HIGH_COLORS,
      unit: "mg/dL",
      description: "Median HDL Cholesterol. Higher is better.",
    },
    tc_value_mean: {
      displayName: "Avg. Total Cholesterol (Mean)",
      dataKey: "tc_value_mean",
      type: "goodIsLow",
      breaks: [180, 200, 220, 240],
      colors: GOOD_LOW_COLORS,
      unit: "mg/dL",
      description:
        "Average Total Cholesterol. High Risk: > 240. Lower is better.",
    },
    tc_value_median: {
      displayName: "Median Total Cholesterol",
      dataKey: "tc_value_median",
      type: "goodIsLow",
      breaks: [180, 200, 220, 240],
      colors: GOOD_LOW_COLORS,
      unit: "mg/dL",
      description: "Median Total Cholesterol. Lower is better.",
    },
    tg_value_mean: {
      displayName: "Avg. Triglycerides (Mean)",
      dataKey: "tg_value_mean",
      type: "goodIsLow",
      breaks: [150, 200, 300, 500],
      colors: GOOD_LOW_COLORS,
      unit: "mg/dL",
      description: "Average Triglycerides. High: > 200. Lower is better.",
    },
    tc_hdl_ratio_mean: {
      displayName: "TC/HDL Ratio (Mean)",
      dataKey: "tc_hdl_ratio_mean",
      type: "goodIsLow",
      breaks: [3.5, 4.0, 5.0, 6.0],
      colors: GOOD_LOW_COLORS,
      unit: "",
      description:
        "Average Total Cholesterol / HDL Ratio. High Risk: ≥ 5.0. Lower is better.",
    },
    ldl_hdl_ratio_mean: {
      displayName: "LDL/HDL Ratio (Mean)",
      dataKey: "ldl_hdl_ratio_mean",
      type: "goodIsLow",
      breaks: [2.0, 2.5, 3.0, 3.5],
      colors: GOOD_LOW_COLORS,
      unit: "",
      description:
        "Average LDL / HDL Ratio. High Risk: > 3.5. Lower is better.",
    },
    ldl_is_high_percentage: {
      displayName: "% LDL High (>160)",
      dataKey: "ldl_is_high_percentage",
      type: "goodIsLow",
      breaks: [5, 10, 15, 20],
      colors: GOOD_LOW_COLORS,
      unit: "%",
      description: "% of individuals with LDL > 160 mg/dL. Lower is better.",
    },
    hdl_is_low_percentage: {
      displayName: "% HDL Low (<40)",
      dataKey: "hdl_is_low_percentage",
      type: "goodIsLow",
      breaks: [20, 30, 40, 50],
      colors: GOOD_LOW_COLORS,
      unit: "%",
      description: "% of individuals with HDL < 40 mg/dL. Lower is better.",
    },
    patient_month_count: {
      displayName: "Test Volumn",
      dataKey: "patient_month_count",
      type: "neutral",
      breaks: [1000, 2500, 5000, 10000, 20000, 50000, 100000],
      colors: NEUTRAL_COLORS,
      unit: "",
      description:
        "Totalnumber of laboratory tests performed in the ZIP code. Higher is better.",
    },
  };
  // SDoH Metric Configs (Keep as is, ensure breaks are good)
  const sdohMetricConfigs = {
    ACS_PCT_UNINSURED: {
      type: "percentage",
      breaks: [4, 6, 8, 10, 12, 14, 16],
      colors: SDOH_COLORS,
      unit: "%",
    },
    ACS_PCT_LT_HS: {
      type: "percentage",
      breaks: [15, 20, 25, 30, 35, 40, 45],
      colors: SDOH_COLORS,
      unit: "%",
    },
    ACS_PCT_HH_PUB_ASSIST: {
      type: "percentage",
      breaks: [25, 35, 45, 50, 55, 60, 65],
      colors: SDOH_COLORS,
      unit: "%",
    },
    ACS_PCT_INC50_BELOW17: {
      type: "percentage",
      breaks: [25, 35, 45, 50, 55, 60, 65],
      colors: SDOH_COLORS,
      unit: "%",
    },
    ACS_PCT_INC50_ABOVE65: {
      type: "percentage",
      breaks: [10, 15, 20, 25, 30, 35, 40],
      colors: SDOH_COLORS,
      unit: "%",
    },
    ACS_PCT_DISABLE: {
      type: "percentage",
      breaks: [10, 15, 20, 25, 30, 35, 40],
      colors: SDOH_COLORS,
      unit: "%",
    },
    ACS_PCT_NONVET_DISABLE_18_64: {
      type: "percentage",
      breaks: [10, 15, 20, 25, 30, 35, 40],
      colors: SDOH_COLORS,
      unit: "%",
    },
    ACS_PCT_VET_DISABLE_18_64: {
      type: "percentage",
      breaks: [10, 20, 30, 40, 50, 60, 70],
      colors: SDOH_COLORS,
      unit: "%",
    },
    HIFLD_MIN_DIST_UC: {
      type: "distance",
      breaks: [2, 5, 8, 12, 16, 20, 25],
      colors: SDOH_COLORS,
      unit: " mi",
    },
    POS_MIN_DIST_ED: {
      type: "distance",
      breaks: [1, 3, 5, 8, 12, 15, 20],
      colors: SDOH_COLORS,
      unit: " mi",
    },
    POS_MIN_DIST_ALC: {
      type: "distance",
      breaks: [5, 10, 15, 20, 25, 30, 40],
      colors: SDOH_COLORS,
      unit: " mi",
    },
    ACS_TOT_CIVIL_EMPLOY_POP: {
      type: "count",
      breaks: [2500, 5000, 10000, 20000, 40000, 80000, 120000],
      colors: SDOH_COLORS,
      unit: "",
    },
    ACS_PCT_COLLEGE_ASSOCIATE_DGR: {
      type: "percentage",
      breaks: [10, 15, 20, 25, 30, 35, 40],
      colors: SDOH_COLORS,
      unit: "%",
    },
    ACS_PCT_BACHELOR_DGR: {
      type: "percentage",
      breaks: [5, 10, 15, 20, 25, 30, 35],
      colors: SDOH_COLORS,
      unit: "%",
    },
    ACS_PCT_GRADUATE_DGR: {
      type: "percentage",
      breaks: [1, 3, 5, 7, 10, 13, 16],
      colors: SDOH_COLORS,
      unit: "%",
    },
    ACS_PCT_HS_GRADUATE: {
      type: "percentage",
      breaks: [20, 25, 30, 35, 40, 45, 50],
      colors: SDOH_COLORS,
      unit: "%",
    },
    ACS_PCT_POSTHS_ED: {
      type: "percentage",
      breaks: [20, 30, 40, 45, 50, 55, 60],
      colors: SDOH_COLORS,
      unit: "%",
    },
    ACS_PCT_HEALTH_INC_BELOW137: {
      type: "percentage",
      breaks: [30, 40, 50, 60, 70, 80, 90],
      colors: SDOH_COLORS,
      unit: "%",
    },
    ACS_PCT_HEALTH_INC_138_199: {
      type: "percentage",
      breaks: [5, 10, 15, 20, 25, 30, 35],
      colors: SDOH_COLORS,
      unit: "%",
    },
    ACS_PCT_HEALTH_INC_200_399: {
      type: "percentage",
      breaks: [5, 10, 15, 20, 25, 30, 35],
      colors: SDOH_COLORS,
      unit: "%",
    },
    ACS_PCT_HEALTH_INC_ABOVE400: {
      type: "percentage",
      breaks: [1, 3, 5, 8, 12, 16, 20],
      colors: SDOH_COLORS,
      unit: "%",
    },
  };

  // --- Map Initialization ---
  const map = L.map("map").setView([18.08, -66.255167], 9);
  L.tileLayer(
    "https://{s}.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}{r}.png",
    {
      attribution:
        "© OpenStreetMap contributors © CARTO | Health: Abartys | SDoH: ACS 2020", // Slightly shorter
      subdomains: "abcd",
      minZoom: 8,
      maxZoom: 14,
    }
  ).addTo(map);

  // --- *** CREATE CUSTOM PANE FOR SDoH CIRCLES *** ---
  map.createPane("sdohPane");
  map.getPane("sdohPane").style.zIndex = 650; // Higher than default overlay (400) and shadow (500), but below markers/popups (600/700/800)
  map.getPane("sdohPane").style.pointerEvents = "none"; // Allow clicks to pass through to the layers below (like ZIP codes)

  // Add the layer group (it will inherit pane settings from its children)
  sdohLayerGroup.addTo(map);

  // --- Get DOM Elements (Keep as is) ---
  const healthMetricSelect = document.getElementById("metric-select");
  const healthMetricDescriptionPanel =
    document.getElementById("metric-description");
  const sdohSelect = document.getElementById("sdoh-select");
  const sdohDescriptionPanel = document.getElementById("sdoh-description");
  const healthLegendDiv = document.getElementById("health-legend");
  const sdohLegendDiv = document.getElementById("sdoh-legend");
  const infoPanel = document.getElementById("info-panel");

  // --- Populate Select Dropdowns (Keep as is) ---
  function populateSelect(selectElement, configObject, defaultKey) {
    selectElement.innerHTML = "";
    const sortedKeys = Object.keys(configObject).sort((a, b) => {
      const itemA = configObject[a];
      const itemB = configObject[b];
      const stringA =
        typeof itemA === "object" && itemA?.displayName
          ? itemA.displayName
          : typeof itemA === "string"
          ? itemA
          : String(a);
      const stringB =
        typeof itemB === "object" && itemB?.displayName
          ? itemB.displayName
          : typeof itemB === "string"
          ? itemB
          : String(b);
      return stringA.localeCompare(stringB);
    });
    sortedKeys.forEach((key) => {
      if (selectElement.id === "sdoh-select") {
        const nonNumericSDoHKeys = [
          "YEAR",
          "COUNTYFIPS",
          "COUNTY",
          "STATE",
          "lon",
          "lat",
        ];
        if (nonNumericSDoHKeys.includes(key) || !sdohMetricConfigs[key]) return;
      }
      const option = document.createElement("option");
      option.value = key;
      const item = configObject[key];
      option.textContent =
        typeof item === "object" && item?.displayName
          ? item.displayName
          : typeof item === "string"
          ? item
          : key;
      if (key === defaultKey) option.selected = true;
      selectElement.appendChild(option);
    });
  }
  populateSelect(
    healthMetricSelect,
    healthMetricConfigs,
    currentHealthMetricKey
  );
  populateSelect(sdohSelect, sdohVariableMap, currentSDoHMetricKey);

  // --- Update Description Panels (Keep as is) ---
  function updateDescriptionPanel(
    panelElement,
    key,
    configMap,
    variableMap = null
  ) {
    let description = "Description not available.";
    if (variableMap && variableMap[key]) {
      description = variableMap[key];
    } else if (configMap && configMap[key]?.description) {
      description = configMap[key].description;
    } else if (configMap && configMap[key]?.displayName) {
      description = configMap[key].displayName;
    }
    panelElement.innerHTML = description
      ? `<p>${description.replace(/\n/g, "<br>")}</p>`
      : '<p class="placeholder-text">Select an indicator.</p>';
  }
  updateDescriptionPanel(
    healthMetricDescriptionPanel,
    currentHealthMetricKey,
    healthMetricConfigs
  );
  updateDescriptionPanel(
    sdohDescriptionPanel,
    currentSDoHMetricKey,
    sdohMetricConfigs,
    sdohVariableMap
  );

  // --- Merge Health Data into GeoJSON (Keep as is) ---
  if (geojsonData?.features && Object.keys(healthStatsLookup).length > 0) {
    geojsonData.features.forEach((feature) => {
      const zipCode = feature.properties.ZCTA5CE10;
      feature.properties.healthData = healthStatsLookup[zipCode] || null;
    });
  } else {
    console.warn("GeoJSON/health stats missing.");
  }

  // --- Styling Functions (Keep getHealthColor, styleHealthLayer, getSDoHColor, getSDoHRadius as is) ---
  function getHealthColor(value, metricKey) {
    /* ... keep existing ... */
    const config = healthMetricConfigs[metricKey];
    if (!config || value === null || value === undefined || isNaN(value))
      return "#E0E0E0";
    const { breaks, colors } = config;
    if (!breaks || !colors || breaks.length === 0 || colors.length === 0)
      return "#E0E0E0";
    if (colors.length < breaks.length + 1)
      console.warn(`Health colors array short for ${metricKey}.`);
    for (let i = 0; i < breaks.length; i++) {
      if (value <= breaks[i]) return colors[i] || "#E0E0E0";
    }
    return colors[colors.length - 1] || "#E0E0E0";
  }
  function styleHealthLayer(feature) {
    /* ... keep existing ... */
    const value = feature.properties.healthData
      ? feature.properties.healthData[currentHealthMetricKey]
      : null;
    return {
      fillColor: getHealthColor(value, currentHealthMetricKey),
      weight: 1,
      opacity: 1,
      color: "#666",
      fillOpacity: 0.7,
    };
  }
  function getSDoHColor(value, metricKey) {
    /* ... keep existing ... */
    const config = sdohMetricConfigs[metricKey];
    if (!config || value === null || value === undefined || isNaN(value))
      return "#999999";
    const { breaks, colors } = config;
    if (!breaks || !colors || breaks.length === 0 || colors.length === 0) {
      console.error(`Invalid breaks/colors for SDoH: ${metricKey}`);
      return "#999999";
    }
    if (colors.length < breaks.length + 1)
      console.warn(`SDoH colors array short for ${metricKey}.`);
    for (let i = 0; i < breaks.length; i++) {
      if (value <= breaks[i]) return colors[i] || "#999999";
    }
    return colors[colors.length - 1] || "#999999";
  }
  function getSDoHRadius(value, metricKey) {
    /* ... keep existing ... */
    const config = sdohMetricConfigs[metricKey];
    const minRadius = 4;
    const maxRadius = 20;
    if (
      !config ||
      value === null ||
      value === undefined ||
      isNaN(value) ||
      value <= 0
    )
      return minRadius;
    let radius;
    let minVal = Infinity;
    let maxVal = -Infinity;
    Object.values(sdohDataLookup).forEach((m) => {
      const v = m[metricKey];
      if (v !== null && !isNaN(v)) {
        if (v < minVal) minVal = v;
        if (v > maxVal) maxVal = v;
      }
    });
    if (minVal === Infinity || maxVal === -Infinity || minVal === maxVal) {
      radius =
        config.type === "count"
          ? minRadius + Math.log1p(value) * 2
          : (minRadius + maxRadius) / 2;
    } else {
      const range = maxVal - minVal;
      radius = minRadius + ((value - minVal) / range) * (maxRadius - minRadius);
    }
    return Math.max(minRadius, Math.min(maxRadius, radius));
  }

  // --- Interaction Functions ---
  function highlightFeature(e) {
    // For ZIP Layer
    const layer = e.target;
    if (layer !== selectedLayer) {
      layer.setStyle({ weight: 3, color: "#051B35", fillOpacity: 0.8 });
    }
    if (!L.Browser.ie && !L.Browser.opera && !L.Browser.edge) {
      if (layer !== selectedLayer) layer.bringToFront();
    }
    // NO need to bring SDoH pane forward here, it stays on top via zIndex
  }

  function resetHighlight(e) {
    // For ZIP Layer
    if (e.target !== selectedLayer) {
      geojsonLayer.resetStyle(e.target);
    }
  }

  function selectFeature(e) {
    // For ZIP Layer
    const layer = e.target;
    if (selectedLayer && selectedLayer !== layer) {
      try {
        geojsonLayer.resetStyle(selectedLayer);
      } catch (error) {
        console.warn("Reset style error:", error);
      }
    }
    map.fitBounds(layer.getBounds().pad(0.1));
    layer.setStyle({
      weight: 4,
      color: "#041427",
      dashArray: "",
      fillOpacity: 0.85,
    });
    layer.bringToFront(); // Bring selected ZIP polygon forward
    // NO need to bring SDoH pane forward here
    selectedLayer = layer;
    updateInfoPanel(layer.feature.properties);
  }

  function onEachFeature(feature, layer) {
    // Attaches interactions to ZIP Layer
    layer.on({
      mouseover: highlightFeature,
      mouseout: resetHighlight,
      click: selectFeature,
    });
  }

  // --- Update Info Panel (Keep as is) ---
  function updateInfoPanel(zipProps) {
    /* ... keep existing logic ... */
    if (!zipProps?.ZCTA5CE10) {
      infoPanel.innerHTML = "<p>Click ZIP area for details.</p>";
      return;
    }
    const zipCode = zipProps.ZCTA5CE10;
    const healthData = zipProps.healthData;
    const municipalityName = zipToMuniMap[zipCode];
    const sdohData = municipalityName ? sdohDataLookup[municipalityName] : null;
    let content = `<h3>ZIP: ${zipCode}</h3>`;
    content += municipalityName
      ? `<h4>Muni: ${municipalityName}</h4>`
      : `<p><small>(Muni N/A)</small></p>`;
    content += `<hr style="margin:10px 0;"><h4>Health (ZIP)</h4>`;
    if (healthData) {
      const hc = healthMetricConfigs[currentHealthMetricKey];
      const hv = healthData[currentHealthMetricKey];
      const hd =
        hv !== null && !isNaN(hv)
          ? `${parseFloat(hv).toFixed(2)} ${hc.unit || ""}`
          : "N/A";
      content += `<p><span class="data-label">${hc.displayName}:</span> <strong class="data-value">${hd}</strong></p>`;
    } else {
      content += `<p>No health data.</p>`;
    }
    content += `<h4 style="margin-top:15px;">SDoH (Muni)</h4>`;
    if (sdohData) {
      const sc = sdohMetricConfigs[currentSDoHMetricKey];
      const sv = sdohData[currentSDoHMetricKey];
      const sd =
        sdohVariableMap[currentSDoHMetricKey] ||
        sc?.displayName ||
        currentSDoHMetricKey;
      const sdv =
        sv !== null && !isNaN(sv)
          ? `${parseFloat(sv).toFixed(sc?.type === "percentage" ? 1 : 2)}${
              sc?.unit || ""
            }`
          : "N/A";
      content += `<p><span class="data-label">${sd}:</span> <strong class="data-value">${sdv}</strong></p>`;
      content += `<p style="margin-top:10px;"><small><i>Other examples:</i></small></p>`;
      const exampleSDoH = [
        "ACS_PCT_UNINSURED",
        "ACS_PCT_LT_HS",
        "ACS_PCT_HH_PUB_ASSIST",
        "ACS_PCT_DISABLE",
      ];
      exampleSDoH.forEach((key) => {
        if (
          key !== currentSDoHMetricKey &&
          sdohData[key] !== undefined &&
          sdohVariableMap[key] &&
          sdohMetricConfigs[key]
        ) {
          const v = sdohData[key];
          const d = sdohVariableMap[key];
          const c = sdohMetricConfigs[key];
          const dv =
            v !== null && !isNaN(v)
              ? `${parseFloat(v).toFixed(c.type === "percentage" ? 1 : 2)}${
                  c.unit || ""
                }`
              : "N/A";
          content += `<p style="font-size:0.9em;"><span class="data-label">${d}:</span> <span class="data-value">${dv}</span></p>`;
        }
      });
    } else if (municipalityName) {
      content += `<p>No SDoH data for ${municipalityName}.</p>`;
    } else {
      content += `<p>Cannot determine muni.</p>`;
    }
    infoPanel.innerHTML = content;
  }

  // --- Update Legends (Keep as is) ---
  function updateHealthLegend(metricKey) {
    /* ... keep existing logic ... */
    const config = healthMetricConfigs[metricKey];
    healthLegendDiv.innerHTML = "";
    if (!config?.breaks?.length || !config?.colors?.length) {
      healthLegendDiv.innerHTML = "<p>Health legend N/A.</p>";
      return;
    }
    const { breaks, colors, unit, displayName } = config;
    if (colors.length < breaks.length + 1) {
      healthLegendDiv.innerHTML = `<p>Legend config error.</p>`;
      return;
    }
    let html = `<h5>${displayName} (ZIP)</h5>`;
    const p = unit === "%" ? 1 : 2;
    html += `<span><i style="background:${
      colors[0]
    }"></i> ≤ ${breaks[0].toFixed(p)} ${unit || ""}</span>`;
    for (let i = 0; i < breaks.length - 1; i++) {
      html += `<span><i style="background:${colors[i + 1]}"></i> ${breaks[
        i
      ].toFixed(p)} - ${breaks[i + 1].toFixed(p)} ${unit || ""}</span>`;
    }
    html += `<span><i style="background:${
      colors[colors.length - 1]
    }"></i> > ${breaks[breaks.length - 1].toFixed(p)} ${unit || ""}</span>`;
    html += `<span><i style="background:#E0E0E0"></i> No Data</span>`;
    healthLegendDiv.innerHTML = html;
  }
  function updateSDoHLegend(metricKey) {
    /* ... keep existing logic ... */
    const config = sdohMetricConfigs[metricKey];
    const variableDesc = sdohVariableMap[metricKey] || metricKey;
    sdohLegendDiv.innerHTML = "";
    if (!config?.breaks?.length || !config?.colors?.length) {
      sdohLegendDiv.innerHTML = `<p>SDoH legend N/A.</p>`;
      return;
    }
    const { breaks, colors, unit, type } = config;
    if (colors.length < breaks.length + 1) {
      sdohLegendDiv.innerHTML = `<p>Legend config error.</p>`;
      return;
    }
    let html = `<h5>${variableDesc} (Municipality)</h5>`;
    const numSteps = 5;
    let minVal = breaks[0];
    let maxVal = breaks[breaks.length - 1];
    let hasRange = !(
      minVal === undefined ||
      maxVal === undefined ||
      minVal === maxVal
    );
    const valueRange = hasRange ? maxVal - minVal : 1;
    const stepValue =
      hasRange && valueRange > 0 ? valueRange / (numSteps - 1) : 1;
    for (let i = 0; i < numSteps; i++) {
      const value = hasRange
        ? minVal + i * stepValue
        : type === "count"
        ? Math.pow(10, i + 1)
        : 10 * i;
      const displayValue = i === numSteps - 1 && hasRange ? maxVal : value;
      const radius = getSDoHRadius(displayValue, metricKey);
      const color = getSDoHColor(displayValue, metricKey);
      const precision = type === "percentage" || displayValue < 10 ? 1 : 0;
      const label =
        displayValue >= 1000
          ? (displayValue / 1000).toFixed(precision) + "k"
          : displayValue.toFixed(precision);
      html += `<div style="margin-bottom: 5px;"><span class="legend-circle" style="background-color:${color}; width:${
        radius * 1.8
      }px; height:${
        radius * 1.8
      }px; border-color: #444"></span><span class="legend-circle-label"> ≈ ${label}${
        unit || ""
      }</span></div>`;
    }
    const noDataRadius = getSDoHRadius(null, metricKey);
    html += `<div style="margin-bottom: 5px;"><span class="legend-circle" style="background-color:#999999; width:${
      noDataRadius * 1.8
    }px; height:${
      noDataRadius * 1.8
    }px; border-color: #666"></span><span class="legend-circle-label"> No Data</span></div>`;
    sdohLegendDiv.innerHTML = html;
  }

  // --- Event Listeners (Keep as is) ---
  healthMetricSelect.addEventListener("change", function () {
    currentHealthMetricKey = this.value;
    if (geojsonLayer) {
      geojsonLayer.setStyle(styleHealthLayer);
    }
    updateHealthLegend(currentHealthMetricKey);
    updateDescriptionPanel(
      healthMetricDescriptionPanel,
      currentHealthMetricKey,
      healthMetricConfigs
    );
    if (selectedLayer) {
      updateInfoPanel(selectedLayer.feature.properties);
    } else {
      updateInfoPanel(null);
    }
  });

  sdohSelect.addEventListener("change", function () {
    currentSDoHMetricKey = this.value;
    if (!sdohMetricConfigs[currentSDoHMetricKey]) {
      console.error(`Config missing for SDoH key: ${currentSDoHMetricKey}`);
      sdohLegendDiv.innerHTML = `<p>Viz config missing.</p>`;
      if (sdohLayerGroup) sdohLayerGroup.clearLayers();
      updateDescriptionPanel(
        sdohDescriptionPanel,
        currentSDoHMetricKey,
        null,
        sdohVariableMap
      );
      return;
    }
    drawSDoHLayer(); // Redraw circles (pane ensures they are on top)
    updateSDoHLegend(currentSDoHMetricKey);
    updateDescriptionPanel(
      sdohDescriptionPanel,
      currentSDoHMetricKey,
      sdohMetricConfigs,
      sdohVariableMap
    );
    if (selectedLayer) {
      updateInfoPanel(selectedLayer.feature.properties);
    }
  });

  // --- Drawing Layers ---

  // Draw ZIP Code Layer (into default pane)
  if (geojsonData?.features?.length > 0) {
    geojsonLayer = L.geoJson(geojsonData, {
      style: styleHealthLayer,
      onEachFeature: onEachFeature,
      // No pane specified, defaults to overlayPane (zIndex 400)
    }).addTo(map);
    updateHealthLegend(currentHealthMetricKey);
  } else {
    document.getElementById("map").innerHTML =
      "<p>Could not load map boundary data.</p>";
    updateHealthLegend(currentHealthMetricKey);
  }

  // --- Function to Draw SDoH Circle Layer ---
  function drawSDoHLayer() {
    // console.log(`--- Redrawing SDoH Layer for Metric: ${currentSDoHMetricKey} ---`);
    sdohLayerGroup.clearLayers(); // Clear existing circles from the group
    let circlesAddedCount = 0;
    let dataErrors = 0;

    Object.values(sdohDataLookup).forEach((muniData) => {
      if (
        muniData?.COUNTY &&
        typeof muniData.lat === "number" &&
        typeof muniData.lon === "number"
      ) {
        const value = muniData[currentSDoHMetricKey];
        if (value === undefined) {
          dataErrors++;
        }
        const radius = getSDoHRadius(value, currentSDoHMetricKey);
        const color = getSDoHColor(value, currentSDoHMetricKey);
        const sdohConfig = sdohMetricConfigs[currentSDoHMetricKey];
        const displayValue =
          value !== null && !isNaN(value)
            ? `${parseFloat(value).toFixed(
                sdohConfig?.type === "percentage" ? 1 : 2
              )}${sdohConfig?.unit || ""}`
            : "N/A";
        const sdohDescription =
          sdohVariableMap[currentSDoHMetricKey] || currentSDoHMetricKey;

        const circle = L.circleMarker([muniData.lat, muniData.lon], {
          radius: radius,
          fillColor: color,
          color: "#444444", // Fixed border
          weight: 1,
          opacity: 0.9,
          fillOpacity: 0.8,
          pane: "sdohPane", // *** Assign marker to the custom pane ***
        });

        circle.bindTooltip(
          `<b>${muniData.COUNTY}</b><br>${sdohDescription}: ${displayValue}`,
          { sticky: true }
        );
        sdohLayerGroup.addLayer(circle); // Add circle to the group
        circlesAddedCount++;
      } else {
        dataErrors++;
      }
    });
    // The layer group itself is already on the map and pane setting is inherited
    // No need to call bringToFront here for basic stacking
    // console.log(`Finished SDoH layer: ${circlesAddedCount} circles, ${dataErrors} errors.`);
  }

  // --- Initial Draws ---
  drawSDoHLayer(); // Draw initial SDoH circles into the sdohPane
  updateSDoHLegend(currentSDoHMetricKey);
  updateInfoPanel(null);

</script>
</body>
</html>
